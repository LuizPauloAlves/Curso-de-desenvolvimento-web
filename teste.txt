[MÚSICA TOCANDO]
DAVID MALAN: Muito bem, aqui é CS50. E esta é a primeira semana, nossa segunda semana.
E hoje, lembrem-se de que nos concentraremos nesta outra linguagem de programação chamada C. E nós lhe demos um pequeno vislumbre da última vez, em que eu propus que este código aqui na tela é algo que você irá em breve saber programar, se ainda não o fez.
Mas basta dizer que parece um pouco diferente do que olhamos na semana passada que, foi o Scratch, que foi muito mais lúdico, muito mais gráfico. E assim, permitam-me anunciar que para a maioria de nós, hoje vai ser como um pouco uma mangueira de incêndio. Na verdade, retratado aqui como um velho hack do MIT, em que alguns seniors da indústria ligaram um hidrante de verdade a uma fonte de água. O ditado é que obter uma educação do MIT é como beber de um hidrante.
Hoje vai ser um pouco assim. Porque esse é um tipo de ocasião que você não tem como descrever com clareza.
Mas é uma em que todos nós vamos aprender uma nova língua. E de fato, isso não é algo que fazemos todos os dias. E assim, ao primeiro olhar, vai parecer como uma grande quantidade de nova sintaxe, um monte de novas ideias. E ainda assim, permitam-me tranquilizar vocês, que o que em breve será assim, este código C aqui, é fundamentalmente a mesma coisa que você já viu e agora experimentou na semana passada por meio do Scratch.
Ou seja, dentro desta outra linguagem de programação C, que é mais tradicional, que é mais baseada em texto, em teclado, ainda vamos ver funções, condições, expressões booleanas, loops, e assim por diante. Eles vão a todos parecer um pouco diferente.
Mas as ideias são as mesmas. E muito parecidas como quando se entra na casa de alguém pela primeira vez e analisamos o terreno, vendo muitas coisas novas, que você não tenha visto antes, você normalmente não se preocupa com todos
os detalhes visuais. Você pode simplesmente caminhar e sentar-se. Da mesma forma hoje, estamos prestes a para ver uma série de detalhes
no mundo desta linguagem de programação. Mas o objetivo em questão é ignorar as coisas à primeira vista que não entendemos direito, e se agarrar às ideias que
são familiares da semana passada. Então, como vamos de fato escrever programas de computador?
Como podemos escrevê-los bem? E assim, permita-me propor que há algumas diretrizes
a orientar a escrita do código. Uma delas, é claro, é a correção. E exploramos isso na semana passada, onde a exatidão de seu código
apenas fala para que funcione como pretendido. Quando você clica duas vezes num ícone, quando você executa algum comando,
faz o programa que você ou alguém escreveu comportar-se corretamente? Será que faz o que diz?
Mas há outros aspectos para escrever um bom software e bons programas.
E isso tem a ver com design. E nós aludimos um pouco disso na última semana. Mas com o design é mais algo qualitativo, uma medida mais subjetiva,
como quão bem o seu código está escrito. Então imagine, por exemplo, assistir a uma aula onde você tem que escrever ensaios,
você certamente poderia demonstrar argumentos muito corretos. Mas você poderia fazer isso, escrevendo por muito tempo,
frases divagantes, repetindo a você mesmo, e geralmente não escrevendo um ensaio ou artigo muito bom.
Agora talvez esteja certo. Não há nada no seu texto da sua aula de inglês, história, ou o que quer que seja que você disse que estava incorreto.
Mas você pode não conseguir boas notas, talvez, porque simplesmente não foi muito bem projetado. E assim também, no mundo da programação,
existe esta noção de realmente escrever não apenas o código correto, mas código bem desenhado.
Em que você não se repete. Você escreve um código que é bastante eficiente. Não faz mais trabalho do que precisa.
E, por fim, deixe-me propor para hoje em diante, nesta classe, que existe um terceiro eixo você deve ter em mente quando
trata-se de escrever um bom código. E isso tem a ver com estilo. Isto é muito mais uma estética.
Isto, no análogo mundo da redação de um ensaio, seria usar correta Pontuação, gramática?
Você está traçando novos parágrafos? E esses tipos de estética que fundamentalmente não altere a exatidão do que você está dizendo,
não mudam necessariamente a qualidade dos argumentos que você está apresentando, mas o estilo de seu ensaio, muito parecido com o estilo do seu código,
torna seu código muito, muito mais legível. Portanto, quando se trata de escrever bom código, você o quer primeiro
e principalmente que seja correto, mas também bem projetado e também bem estilizado. Muito parecido, de novo, com um texto que você gostaria que
refletisse bem suas capacidades. Portanto, quando se trata de escrever código, como este, por exemplo,
este primeiro programa C que alguém na semana passada propôs simplesmente imprime na tela, hello, world.
Bem, como vamos escrever este código? Na semana passada, escrevemos o código no Scratch.MIT.edu e depois arrastamos e soltamos peças do quebra-cabeça.
Hoje vai ser um pouco diferente. Vamos usar uma ferramenta diferente aqui. E nós vamos usar nosso teclado muito mais
do que nosso mouse para programar. Mas para fazer isso, nós vamos introduzir a primeira de várias ferramentas deste semestre, conhecido como CS50 IDE.
IDE é um acrônimo, um termo da arte da programação, que significa Ambiente de Desenvolvimento Integrado.
Uma forma extravagante de dizer, neste contexto, que o CS50 IDE é o ambiente de programação baseado na web.
E não é específico do CS50 em si. Nós simplesmente adicionamos recursos úteis do ponto de vista educacional
em cima de uma ferramenta de nuvens de terceiros que qualquer pessoa na internet pode usar.
E nossa própria versão está nesta URL, ide.cs50.io. Portanto, eu recomendo visite essa URL hoje.
Mas não precisa ser durante a aula. Mas sobre este próximo problema e mais além, você vai usar e ficar mais familiarizado com esta ferramenta.
Portanto, agora eu vou abrir esta ferramenta aqui. Portanto, eu já fiz o login antes. E o que você vê aqui é a interface de usuário disponível para você.
E, felizmente, há apenas duas ferramentas em destaque que precisamos abordar agora mesmo. Portanto, no topo da tela,
um grande retângulo preto que logo vai ser preenchido com código. Muito parecido com o uso do Google Docs ou algo assim
assim, onde você pode criar novas abas e criar novos arquivos, aqui é onde eu vou fazer minha programação, ao longo da parte superior da tela.
E ao longo da parte inferior é o que vamos, a seguir, começar a chamar nossa janela terminal. É nesta janela de terminal que eu posso executar comandos e finalmente
executar meu código. Mas vamos em frente e escrevamos nosso próprio primeiro programa neste ambiente e perceber que esta ferramenta, de fato, não é muito específica do CS50.
É destinada a ser representativa de uma ferramenta de programação popular onde você tem um chamado editor de texto,
ou janelas com abas onde você pode escrever código, e uma janela terminal onde você pode executar comandos. A nossa está na nuvem.
Mas você pode, alternativamente, programar em seu próprio Mac, ou PC, ou qualquer outro dispositivo.
Mas isso costuma envolver uma infinidade de dificuldades técnicas no início especialmente quando todos nós
temos diferentes versões do Mac OS e Windows e similares. Portanto, este ambiente baseado na nuvem apenas garante que no dia zero,
todos nós podemos ter a mesma experiência de programação. Por isso, vou fazer logo isso
Vou continuar e subir em Arquivo e Novo Arquivo. E isto vai criar uma nova aba, por padrão chamada Untitled1,
nada interessante. Por isso, vou agora até Arquivar e Salvar. E por padrão, eu vou salvar este arquivo como, por exemplo,
o nome hello.c. Portanto, quero escrever meu primeiro programa neste idioma chamado C. Vou chamar meu arquivo de "olá".
Mas vou terminar em uma extensão de arquivo chamada .c. E essa é de fato a convenção. Ao escrever programas C, eles devem terminar com .c.
Assim como os programas Scratch, como você deve se lembrar, terminam em .sb3. Portanto, vou clicar aqui no botão verde
que se chama Salvar. Nada vai mudar com exceção do nome e da aba ali. Agora eu vejo no topo à esquerda que esta aba é chamada de hello.c.
E agora eu posso começar digitando o que eu quiser. E francamente, eu vou digitar de memória o primeiro programa que vimos na semana passada e há apenas um momento.
Vou fazer incluir stdio.h, o que quer que isso seja por agora. Vou então fazer int main(void), o que quer que isso seja por enquanto.
Vou usar a chave. E depois fechar essa chave, por assim dizer, depois disso. E aqui, vou continuar e fazer printf("hello, world") seguido
por ponto-e-vírgula. Isso foi um monte de texto que tirei da cabeça. Este é o tipo de memória que você vai desenvolver em breve
ao escrever um programa. Eu, é claro, já fiz isto muitas vezes antes. Então, eu pude fazer apenas tirando da cabeça.
Mas em um momento, vamos separar o que todas as várias linhas e caracteres que eu digitei, faz.
Mas agora eu gostaria mesmo é de executar esse programa. Entendemos na semana passada que isso vai apenas imprimir hello, world.
Mas como? Bem, no mundo dos nossos Macs, PCs e telefones, todos nós apenas tocaríamos num ícone se quiséssemos executar um programa.
Não é o caso hoje, porque agora estamos em um ambiente de programação mais tradicional.
O ambiente que agora estamos requer que eu use meu teclado um pouco mais, ou o que é conhecido como Interface de Linha de Comando, ou CLI.
Contrasta com uma interface gráfica de usuário, ou G-U-I, ou GUI, que é o que descreve o Mac, OS Windows, iOS, e Android.
Mas em uma interface de linha de comando, eu tenho que fazer tudo em uma linha de comando. E com isso, eu me refiro a esse prompt piscante
em minha tela. Ao longo da parte inferior de minha tela mais uma vez, descrita como janela terminal, onde eu vou digitar os comandos,
e esta é minha interface de linha de comando. Qualquer coisa que eu digite aqui será enviada para este computador
e, espera-se que ele execute em seu próprio hardware. Então, como faço isso?
E o que eu faço? Bem, a pegadinha, é claro, é que ao escrever código em C ou Python
ou Java ou várias outras que por acaso existam, que deve para ser escrito e entendido por mim e por vocês, os humanos.
Mas, na semana passada, qual única linguagem, em certo sentido, nós vimos que os computadores entendem? Brian, poderíamos chamar alguém para responder essa?
Que língua apenas computadores falam?
Porque eu acho que há uma desconexão entre o ponto de partida da semana passada e onde estamos no momento, se eu estiver codificando algo assim.
Cindy, que linguagem os computadores falam, você diria? PLATEIA: Binário. DAVID MALAN: Binário.
Explique um pouco melhor. O que você quer dizer com binário, para recapitular? PLATEIA: Sim. Então eles usam 1's e 0's para representar tudo.
DAVID MALAN: Exatamente. Eles usam 1's e 0's para representar tudo. E na semana passada nos concentramos apenas em coisas como números e letras
e cores e imagens e vídeos e som e assim por diante. Mas não falamos sobre mais funcionalidade, no que os computadores também
usam 0's e 1's para representar. Ou seja, computadores, é claro, têm hoje em dia a capacidade de imprimir
coisas na tela. E essa noção de impressão, essa função, essa funcionalidade,
também está sendo representada sob o capô de um computador, por assim dizer, por algum padrão de 0's e 1's.
O que quer dizer que tudo o que acabei de digitar, apesar de ser uma coisa mais ou menos parecida com o inglês
e como que diz claramente: "hello, world", o computador, ironicamente, não sabe o que é que eu acabei de digitar.
Para que ele entenda o que acabo de digitar, eu preciso realmente converter para 0's e 1's. E assim, de fato, a próxima etapa neste processo
é pegar o que eu descreverei como meu código fonte, escrito aqui em C, e na semana passada, também vimos o código-fonte, era apenas gráfico.
Eram aquelas peças de um quebra-cabeças no Scratch. Este é o meu código fonte que, apesar de críptico, é algo que eu, pelo menos, o humano, eventualmente sei ler e escrever.
Mas eu preciso literalmente converter para padrões de 0's e 1's que o computador possa entender.
Agora, como chegar a este ponto? Bem, felizmente, nós temos um modelo mental da semana passada que envolve a solução de problemas.
E aqui está um problema. Como eu levo o código fonte, escrito nesta língua supostamente chamada C, e converto em 0's e 1's que o computador entende?
Bem, minha contribuição, ouso dizer, vai ser meu código fonte. E meu output, idealmente, será o que chamaremos código de máquina.
Código de máquina é apenas um termo descrevendo os 0's e 1's que os computadores entendem. Não usamos essa expressão na semana passada.
Mas isto se refere apenas a 0's e 1's à direita e o código C à esquerda. Então, isso convida a perguntar o que está entre meu código fonte
e o código de máquina? Se eu pegar meu código fonte e alimentar a proverbial caixa preta, como saio desta caixa preta com os 0's e 1's que o computador
entende? Bem, eu preciso de um programa que começaremos a chamar compilador. Um compilador é um programa que você pode baixar gratuitamente,
ou pode ser pago também, que é um programa projetado para converter o código fonte em código de máquina.
Portanto, tudo o que preciso fazer se eu quero resolver o problema, como dito anteriormente, pelo qual escrevi este código em C
e agora eu preciso converter a 0's e 1's, eu só preciso de acesso a um compilador.
E acontece que um desses existem dentro do CS50 IDE. E esta é uma ferramenta que você poderia baixar em seu próprio Mac ou PC ou similares.
Por agora, vamos descrever essa ferramenta como sendo algo simples, "make". Literalmente, se eu quiser que meu programa faça algo,
eu digito "make hello". E depois vou usar um pouco de uma sintaxe críptica, ./hello.
Mas vamos ver isso em ação para amarrar tudo isso. Vou mover meu cursor na janela do meu terminal,
ou minha interface de linha de comando. E eu vou literalmente digitar hello. Note que eu não vou digitar hello.c.
Vou digitar o nome do programa a fazer isso e eu só quero chamar este programa hello.
O compilador vai inferir a partir deste comando que eu pretendo compilar um arquivo chamado hello.c.
Vou continuar e clicar em Enter. Há uma saída críptica louca. Em outro dia em explico isso. Mas o fato de que eu não vejo qualquer mensagem de erro alarmante
é uma coisa boa. Isto significa que meu programa foi compilado com sucesso. Por quê? Não vejo alarmantes mensagens para dizer o contrário.
Mas agora, se eu quiser executar este programa, Eu preciso digitar um comando diferente, que é o análogo do duplo
clique em um ícone em seu Mac ou PC ou telefone. Vou digitar literalmente ./hello.
./hello é como dizer "vá na pasta atual do computador que estou usando e procure por um programa chamado "hello".
Vou continuar e vou pressionar Enter e voilá, "hello, world". Agora eu vejo, novamente, um sinal de dólar e algum outro texto na tela.
E logo vamos explicar melhor o que isso quer dizer. Mas veja que, este sinal de dólar é apenas um lembrete visual constante
de onde está meu prompt, onde eu posso digitar mais comandos. E o computador já fez literalmente o que eu perguntei.
Imprimiu o "hello, world". E agora ele está esperando pelo meu segundo comando. Então esse foi o análogo de apenas imprimir hello, world fora da boca do gato
na semana passada. Mas certamente podemos fazer mais do que isso. Mas vamos ligá-lo de volta ao que fizemos na semana passada também.
Para que nem tudo aqui seja assim tão diferente. Portanto, lembrem-se que na última semana, nós tínhamos funções.
E acontece que tínhamos algo chamado argumento, apesar de não termos necessariamente descrito assim. Portanto, uma função é como um miniprograma.
É uma ação ou um verbo que você pode usar ao escrever seu próprio programa que faz algo. Vimos o bloco de "dizer" (say) na semana passada.
Vimos o bloco de espera (wait) na semana passada. Esses eram verbos, ou ações, ou funções geralmente percebidas.
Mas as funções também podem ter inputs, re-chamadas, e nós vimos isso na semana passada. E hoje em dia, vamos começar chamando inputs para argumentos de funções,
por assim dizer. Outro termo para isso é parâmetro. Mas para todos os efeitos, são sinônimos.
Os argumentos são as inputs para as funções. Portanto, vamos considerar então, da semana passada, o chamado bloco que vimos da última vez, que simplesmente está tentando dizer
da boca do gato, hello, world. Bem, agora eu vou converter isto, se preferir, ao código C correspondente,
apenas para enfatizar o quanto semelhante, essas duas linguagens são, ainda que sintaticamente C pareça absolutamente diferente.
Acontece que se você quiser dizer algo em C, utilizando esta linguagem baseada em texto, como eu fiz agora,
você não vai escrever "say". Você vai, ao invés disso, escrever "print". Isso é, na verdade, uma mentirinha inocente. Você não vai dizer "print".
Na verdade, você vai dizer printf, por razões que veremos a seguir. Isso significa imprimir algo formatado, ou coisa assim.
Assim, o printf é o análogo em C de "say" no Scratch. Agora repare que em C, eu tenho estes parênteses abertos
e parênteses fechados que, agradavelmente são um pouco ovulares. E repare que eles imitam a oval branca
para a qual fornecemos informações na semana passada. Portanto, no meio desses parênteses estarão meus inputs dessa função, printf, também conhecido como argumentos.
Mas eles vão ser um pouco diferentes esta semana. Sim, vou dizer hello, world, com uma vírgula no meio,
gramaticalmente, assim como na semana passada. Mas no mundo do C, eu tenho de ser mais específico. Também tenho que acrescentar aspas duplas à esquerda e à direita.
E, de forma um tanto irritante, eu também tem que acrescentar um ponto-e-vírgula no final desta linha de código.
Assim como em inglês, ou em muitas línguas humanas, você termina uma frase, por exemplo, com um ponto, em muitas linhas de código que você vai escrever em C
você também tem que terminar seu pensamento, neste caso, com um ponto-e-vírgula. Isto, então, à direita, é o caminho mais próximo
de traduzir esta coisa à esquerda do Scratch para C, respectivamente.
Portanto, as ideias ainda são as mesmas. Mas a sintaxe parece um pouco diferente. E só temos que incutir em nós mesmos, em última análise,
que padrões são esses, e quais são as convenções humanas. Mas note que o que acabamos de fazer segue o mesmo paradigma da semana passada.
Mas vamos acrescentar um pouco de terminologia esta semana. Na semana passada, descrevemos a caixa preta como sendo potencialmente algoritmos,
inicialmente. E então começamos chamando-os de funções. As funções são apenas uma versão programada de um algoritmo, a implementação
de um algoritmo em código, em software. Assim, uma função pode ser representada aqui como sendo a tomada de inputs conhecida de outra forma
como argumentos. Mas acontece que as funções podem fazer pelo menos dois tipos diferentes de coisas
no mundo da programação. E vimos isso já, mas não descrevemos tão particularmente como o faremos hoje.
Quando uma função recebe inputs, ou seja, argumentos, assim como o "hello, world" é um input para o bloco "say" no Scratch
ou a função printf em C, funções pode ter o que se chama efeitos colaterais.
E lembre-se, nós vimos isso da última vez. Quando usamos o bloco "say", ele retornou um output.
Mas, mais tecnicamente, tinha um efeito colateral visual. Quando eu usei o bloco say na semana passada e a função printf esta semana,
você viu algo na tela. E isto é, sim, alguma forma output. Mas é um pouco diferente de uma forma diferente de output
que vimos da última vez. Portanto, um efeito colateral de uma função é frequentemente algo visual que acontece na tela, como texto ou áudio, nesse caso.
Mas há esta outra característica de funções que vamos ver e usar hoje conhecida como retorno de valores, onde uma função pode realmente
devolver um valor. Não vai dizer isso na tela. Não vai vocalizá-lo audivelmente.
Vai apenas devolver para você de uma forma que você, o programador, pode reutilizar qual seja o output dessa função
idealmente, armazenando em uma variável. Assim, por exemplo, lembre-se da última semana, quando perguntamos ao humano
seu nome por meio deste bloco de perguntas. E o input para o bloco de perguntas em esta oval branca era, qual é o seu nome?
E depois lembre-se que este bloco de perguntas foi um pouco especial na semana passada. Porque nos deu acesso a qualquer coisa que o humano digitasse.
E isso quer dizer que o bloco de perguntas na semana passada devolveu um valor.
Não apenas exibia cegamente qual fosse a palavra que o humano digitasse na tela.
Não, ao invés disso, devolveu em certo sentido metaforicamente armazenando em uma variável chamada resposta.
E assim, mais uma vez, essa é a diferença. O bloco "say" diz literalmente algo na tela. E há um efeito visual imediato.
Com o bloco de perguntas, após digitar seu nome, você não vê seu nome impresso ou exibido novamente na tela.
Em vez disso, seu nome fica escondido em uma variável, assim como um matemático armazenaria um número em uma variável, como x ou y ou z.
O ônus estava então sobre nós, os programadores, na semana passada para fazer algo com o valor, "meu nome", que
estava naquela variável chamada resposta. Então, como vamos traduzir o bloco de pergunta para o bloco C hoje?
Bem, acontece que há diferentes maneiras de fazer isso em C, nenhuma das quais muito fáceis, a menos que você use o que é chamado de biblioteca.
Uma biblioteca é um código que outra pessoa escreveu. E de fato, uma das coisas que vamos usar hoje é a chamada biblioteca CS50, que é um monte de código,
que o staff e eu escrevemos apenas para facilitar a realização de coisas simples. Estas são rodinhas de treinamento onde decolaremos
dentro de algumas semanas. Mas, para conseguir começar rapidamente, é será mais fácil fazer coisas como obter texto do usuário.
Então string é um termo no mundo da programação. Uma string é um texto.
É uma palavra. É uma letra. É um parágrafo. É uma página de texto. É apenas um texto de alguma forma.
String é o que um cientista da computação chamaria de texto. get_string é uma função que nós escrevemos que vai
fornecer a você o aceite de inputs. Perceba, por parênteses aqui em C, ele pode receber entrada.
Qual poderia ser essa entrada? Bem, assim como o bloco "ask", vai ser um prompt que o humano deve finalmente ver.
Portanto, há um pouco mais de envolvimento, do que apenas usar esta função. Quando você usa get_string em C, como veremos em breve em uma demonstração ao vivo,
você quer fazer algo com o nome do humano. E para fazer algo com o nome do humano, não basta apenas confiar que o Scratch
vai colocar em uma variável para você. Em C, como na maioria das linguagens de programação, é muito mais autonomático.
se você quiser que algo seja armazenado em uma variável, você mesmo tem que fazer isso. O MIT não vai, magicamente, colocar em uma variável resposta por você.
Você mesmo tem que fazer isso. Então, para fazer isso, você simplesmente inventa o nome da variável que você deseja,
seja x ou y ou z, ou de forma mais convincente, "answer", e você usa um sinal de igual.
E mesmo que em matemática isso geralmente implique igualdade, no contexto do C, e na maioria das linguagens de programação, o sinal de igualdade na verdade
significa o que chamaremos de atribuição. Significa, efetivamente, copiar o que estiver à direita
no que quer que esteja à esquerda. Portanto, se do lado direito houver uma função cujo propósito
é perguntar ao humano seu nome é, esse nome vai ser copiado da direita para a esquerda
para esta variável chamada resposta. O MIT fez isso automaticamente para nós no Scratch. Em C, você tem que fazer você mesmo.
Mas você tem que ser um pouco mais específico, também. Acontece que no mundo do C, você não pode ter apenas variáveis.
Você tem que dizer ao computador, antecipadamente, que tipo de variável você deseja. Aqui eu vou dizer ao computador que o tipo de variável
que eu quero é uma string. E a convenção para fazer isso é você escrever literalmente o nome do tipo
que você quer, sendo a string o único que vimos até aqui. Em seguida, você escreve o nome da variável.
E então, novamente, para atribuir um valor a essa variável da direita para a esquerda, temos que usar o sinal de igual aqui.
E agora, apenas uma pausa rápida. Brian, se pudéssemos chamar alguém para essa, mesmo que você nunca tenha programado antes, se você já levou a sério
um dos meus conselhos anteriores. Ainda falta algo aqui. Como eu poderia querer terminar a tradução deste código do Scratch
para C no lado direito? O que está faltando do seu ponto de vista?? Se você já programou antes, provavelmente vai ser intuitivo.
Se você nunca programou antes, você vai precisar lembrar o que eu disse anteriormente. Jacob, o que você acha?
PLATEIA: Ponto-e-vírgula? DAVID MALAN: Exatamente. Há apenas um ponto-e-vírgula simples,
que está faltando no final da linha, que é necessário para deixar claro para o computador que este é o fim deste pensamento.
E eu acho isso meio imbecil. Porque, honestamente, uma das maiores frustrações ao aprender a codificar, como acontecerá hoje, esta semana e além,
é que, inicialmente, você vai esquecer coisas estúpidas como o ponto-e-vírgula, ou você vai esquecer uma aspas simples, ou um parênteses,
essas coisas. E o principal conselho que posso dar hoje é tente não ficar frustrado com essas coisas bobas.
Há coisas melhores ainda. É muito mais útil na vida entender funções e loops e condições e não deixar-se frustrar
pelas coisas estéticas menores que honestamente vêm apenas com a prática. Portanto, se o primeiro erro seu é faltar um ponto-e-vírgula,
e levar 10 minutos, uma hora para descobrir o que está errado com seu código, totalmente normal.
E essas frustrações vão passar muito rapidamente com o tempo. Assim, temos então esta tradução de uma função para outra.
Aonde mais podemos ir? Bem, vamos dar uma olhada em uma outra tradução que usamos depois desse bloco de perguntas.
Na semana passada, após termos perguntado ao humano seu nome, fornecendo um input para a função e obtendo algum output,
então procedemos a fazer algo com o valor de retorno ou output da pergunta.
Mais uma vez, perguntamos ao humano seu nome. Scratch magicamente, na semana passada, colocou o nome na variável de resposta.
Mas então eu fiz algo com ela. E isto é o que eu quero dizer sobre distinguir efeitos colaterais, que simplesmente acontecem
para você, como algo impresso na tela, como o gato dizendo algo, versus um valor de retorno,
que é um pedaço de informação, como um nome que um humano digitou ao ser armazenado em algum lugar onde você, o programador, pode fazer uso mais tarde.
Isso não está acontecendo com você. Está sendo entregue a você para uso posterior. E na semana passada, a fim de dizer "hello, vírgula, mundo", de uma vez só,
nós meio que tivemos que empilhar estas peças do quebra-cabeças uma sobre a outra, fazendo o output do join o input de "say" (diga).
Em C, isto é um pouco mais fácil, apesar de ser uma nova sintaxe. Novamente, o printf vai ser o análogo de say.
E já vimos isso há pouco. Nós ainda vamos ter os parênteses. Ainda vamos ter o ponto-e-vírgula.
Então o que vai dentro do input? Como faço para fornecer "hello, answer" para o C?
Bem, vou continuar, "hello" em aspas duplas, e então esta estranha nova sintaxe aqui, %s.
Isto é o que vamos chamar de formato de código, portanto o f em printf.
O printf não apenas imprime coisas. Ele também pode imprimir códigos de formato. E isto é apenas uma sintaxe extravagante dizendo "coloque algum valor aqui".
Não imprimir "s", de fato. Este é um placeholder para o que será s, uma string.
Bem, o que eu quero colocar lá? Aqui está algo novo, também. No Scratch, se você tivesse dois inputs para uma função,
daria a você duas ovais como esta e esta aqui você poderia digitar palavras ou números ou arrastar variáveis.
Em C, não há noção de ovais ou gráficos. Então, ao invés disso, vamos usar apenas uma vírgula.
Se você usar uma vírgula no meio de parênteses como argumentos ou inputs para uma função, ou seja separando o que há na esquerda
do que está à direita, sendo assim análogo a ter duas ovais no mundo do Scratch, agora há
algo que é potencialmente um pouco confuso visualmente. Na verdade, há duas vírgulas aqui, é claro, e aqui.
Mas veja com atenção o detalhe. Aquele primeiro, que é uma vírgula gramatical inglesa que coloquei dentro da minha string com aspas, minha frase.
Isso não tem nada a ver com programação. Tem tudo a ver com inglês. O fato de que esta vírgula está fora dessas aspas duplas,
no entanto, significa que é significativo nesta língua chamada C. E separa o primeiro argumento do segundo.
E assim, desta forma temos a capacidade para também dizer algo na tela usando o printf desta forma ligeiramente nova.
Então, agora vou fazer isso de verdade. Voltando ao CS50 IDE.
E vou continuar e voltar para este programa aqui e considerar por apenas um momento como nós
podemos melhorar esse primeiro programa que, literalmente, apenas imprime hello, world. Não é tão interessante assim.
Posso rodar isso o dia inteiro. Vai dizer a mesma coisa. Como posso receber agora o input do usuário?
Bem, acontece que eu posso simplesmente melhorar um pouco este código. Agora, de acordo com a tradução do Scratch, que fizemos antes,
vou fazer tipo string answer igual a get_string("Qual é o seu nome?").
Então eu estou literalmente digitando o que vimos em C há um momento atrás.
Vou lembrar do meu ponto-e-vírgula aqui. E então eu tenho que mudar esta segunda linha de código agora para não dizer hello, world,
mas dizer "hello, %s". E então, fora das aspas duplas, vou digitar uma vírgula
e depois fornecer literalmente a palavra answer, que é o nome dessa variável.
Mas eu ainda não terminei. E isto é um pouco sutil. Sem dúvida, você vai esquecer isto em algum momento. Para usar o get_string, eu tenho que usar esse negócio
chamado biblioteca CS50, código que o staff escreveu e que você não tem acesso padrão. E, para fazer isso, eu preciso adicionar uma linha de código
que explicaremos em mais detalhes em um instante. Mas, por enquanto, acredite que ao adicionar esta linha de código
no topo, incluindo CS50.h, que agora me dá acesso à função,get_string que eu de outra forma
não teria acesso. Muito bem, agora eu vou voltar para a janela do terminal. E repare na dicotomia aqui.
Se eu simplesmente rodar ./hello, com um pouco de entusiasmo, vamos ver o que meu novo programa faz. Estou prestes a ser, infelizmente, frustrado.
Porque ainda diz "hello, world". E você pode perceber intuitivamente qual é o problema, é claro, de fato eu não recompilei o código.
E assim, sempre que fizer uma mudança no seu código, não basta apenas salvar o arquivo via file save ou Control
ou Command-s, é preciso recompilá-lo. E recompilar meu código, não é nada de mais.
Basta digitar make hello enter. Agora eu torço que não haja nenhum texto amarelo ou vermelho.
Está tudo bem. Parece ter compilado em código de máquina. Agora eu posso digitar de novo ./hello.
e enter. E você verá agora meu programa está rodando e esperando por mim. agora vou digitar meu nome, David enter hello, David.
Agora eu vou rodar novamente depois de limpar a tela. Vamos executar novamente. E desta vez, vamos dizer que meu nome é Brian.
E eu digo hello, Brian. Tão parecido com o que fizemos no Scratch, mas agora estamos fazendo mais poderosamente tudo isso apenas através do meu teclado.
Muito bem, foi muita coisa já. Nós escrevemos hello, world super rapidamente puxando tudo da memória e então aprimoramos, recebendo informações do usuário.
Vou fazer uma pausa aqui. Se houver alguma dúvida, você está convidado a perguntar via chat para o staff ou colegas de classe.
Mas, se você gostaria de levantar sua mão virtual no Zoom, por favor, fique à vontade para que eu possa esclarecer ou expor sobre qualquer coisa aqui.
Sim, pergunta do Ryan? PLATEIA: Eu tinha perguntado isto no chat. A string antes da resposta, não é esse o nome da variável.
Por isso, hipoteticamente, você poderia conseguir, tipo, string A ou string qualquer outra coisa.
Só o que importa depois da string é o nome da variável? DAVID MALAN: Exatamente. uma boa pergunta. No mundo do Scratch, você foi solicitado
a usar a variável chamada "answer". Em C, temos total flexibilidade sobre o que desejamos fazer.
Então, como Ryan propôs, eu poderia mudar o nome da variável, abreviar apenas para A. Eu teria que mudar em outro lugar, também,
para deixar claro que a variável sendo utilizada é a mesma, com um nome diferente. Está perfeitamente bem.
Mas aqui é onde agora chegamos em uma questão de melhor estilo.
Ter uma variável chamada apenas A, não atende à legibilidade de seu código.
Eu poderia agora dar uma olhada no meu código e pensar qual é a variável A. É um pouco melhor ao escrever um bom código, ser mais verboso
e usar uma palavra real como "answer", neste caso. De fato, mesmo que eu continue descrevendo x e y e z
como variáveis, para um matemático, elas de fato não significam nada fora do contexto de um plano cartesiano.
Então, em um programa, em C ou Scratch ou qualquer outra coisa, usar nomes descritivos de variáveis é também uma questão de bom estilo.
Jonathan, para você. PLATEIA: Sim. Apenas uma pergunta rápida. Por que temos que compilar o código todas as vezes?
E, ao contrário das diferentes IDEs, que se você simplesmente executar o código, ele compila automaticamente. Por que temos que fazê-lo manualmente?
DAVID MALAN: Sim. Uma pergunta muito boa. Por que você tem que manter recompilando o código? A resposta curta é apenas porque é assim que o C funciona.
É uma língua mais antiga, com décadas de idade. Tudo foi muito discutido dentro da realidade que havia.
A interface do usuário não era a principal prioridade. O desempenho sim, por exemplo. E assim, hoje em dia, existem os mais sofisticados ambientes de desenvolvimento integrado.
E alguns de vocês podem ter usado coisas como a codecademy online, ou co.org, onde há muitas vezes, um botão de play que você pode simplesmente
clicar na interface do usuário, e ele apenas roda seu programa ou executa seu programa. O que estamos fazendo nessa aula é mostrar a você
o que esses botões estão fazendo. Portanto, se você usar em um ambiente assim, que parece automatizar isso,
essas coisas ainda estão acontecendo. Mas, para nossos propósitos, certamente no início do semestre, vamos fazer isso manualmente.
Mais tarde, quando introduzirmos uma linguagem completamente diferente, por exemplo, Python, então, você meio que
não precisará mais compilar, mas voltaremos nisso em algumas semanas. Boa pergunta. Sophia?
Com você. PLATEIA: Eu tinha uma pergunta sobre isso Eu notei que no código fonte há uma contrabarra, como n, no fim da string.
Isso é necessário sempre, mesmo que seja apenas uma linha? DAVID MALAN: Uma pergunta muito boa. Esta barra invertida que você está vendo em outro lugar, um spoiler.
Mas sim, vamos em frente e consertar este problema que temos visto, mesmo que eu esteja meio que ignorando. Sabe, isto agora fica um pouco pessoal.
Mas isto parece meio estúpido, honestamente. Diz hello, Brian til barra sinal de dólar. Não é o output desejado por mim.
Eu só queria dizer, literalmente hello, Brian, ou hello, David. Este artefato visual aqui, o sinal de dólar e o til e a barra
tem a ver com minha janela terminal, este ambiente de linha de comando que eu estou usando. E, honestamente, sendo um pouco ousado,
francamente, deveria provavelmente estar em uma nova linha. Deve estar apenas em sua própria linha, portanto não confunde-se com meu output.
E como observa Sophie, ali está uma solução para isto. Mas, novamente, na semana passada, você precisava m ao escrever algoritmos
e, por sua vez, codificar, você precisa ser super preciso. Em nenhum lugar do meu código eu disse ao computador
para mover o cursor para a próxima linha. Portanto, posso fazer isso explicitamente, fazendo contrabarra n imediatamente após %s.
Mas ainda dentro das aspas duplas. Esta é uma notação curta para o que estaria dizendo ao computador,
mova o cursor para a próxima linha. Agora você pode pensar que, bem, por que eu apenas não dou Enter?
E apesar de tudo isto poder ser novo para a maioria, basta dizer parece que vai ficar muito confuso rapidamente.
Começar a pressionar Enter no meio do seu código, essa provavelmente não é a solução correta. Portanto, ao invés disso, os programadores anos atrás decidiram
fazer uma notação de curto prazo, como a contrabarra n, também conhecida como um caractere de escape, que sinaliza ao computador "uma nova linha aqui".
Portanto, a contrabarra n é uma nova linha. Agora eu vou recompilar isto. Depois de salvar meu arquivo, vou agora fazer um make hello.
Parece estar compilando OK. ./hello. Agora eu vou digitar novamente o nome Brian. E voilá, ainda a mesma saída, mas um pouco mais limpa.
Portanto, estamos fazendo a manutenção da casa um pouco melhor agora. Uma pergunta muito boa.
BJ, certo? PLATEIA: Sim. Então, uma pergunta que eu tinha é por que você não tem
de chamar a função get string para que você peça um input? Como se ainda pedisse a sua opinião quando você atribuiu à variável answer.
DAVID MALAN: Ah, uma boa pergunta. Por que eu não tenho que chamar get string, por exemplo, colocando ela em uma linha própria?
A maneira que C e muitas linguagens de programação funcionam é avaliando toda uma linha de código, por exemplo,
o que eu tenho aqui na linha seis da direita para a esquerda, pelo menos neste contexto.
Quando você tem um sinal de igualdade no código, como aqui, isso diz ao computador "você tem que executar primeiro isso",
"que está no lado direito". E então o que quer que a saída dessa coisa seja, armazene isso no lado esquerdo.
Portanto, está de fato sendo executado, estamos agora mesmo espalhando as coisas em linhas de código mais longas, se preferir, se isso fizer sentido para você.
Então, get string está sendo executada porque aparece nessa linha.
Muito bem. Então nós pulamos, na verdade, alguns detalhes destes programas que, provavelmente,
para ser justo, precisamos destrinchar. Por exemplo, havia aquele int, main, void, e toda uma série de outras sintaxes.
Por isso, vamos separar algumas destas outras linhas de código que acabei de digitar puxando da memória, mas meio que
precisam estar lá em cada programa C que você escrever. Vamos ao menos começar a entender melhor alguns desses detalhes. Lembre-se de que no Scratch, nós sempre iniciamos nossos programas
com quando a bandeira verde é clicada. Acabamos vendo alguma outra peça de quebra-cabeças, como quando há um evento,
ou quando há movimento de câmera. Mas este pontapé deu início à maior parte dos programas que escrevemos no Scratch.
Qual é o análogo em C de quando a bandeira verde clica a peça de quebra-cabeça?
É isto. Não vamos passar tempo hoje explicando isso em detalhes por que é int, por que é void, por que há chaves, porque há parênteses.
Para o dia de hoje, deixe-me apenas estipular que este é o análogo para quando a bandeira verde clica na peça.
Você só tem que começar seus programas com este tipo de código-base, por assim dizer. Vamos começar a explicar isto em muito mais detalhes.
Mas por enquanto, basta acreditar que é assim que você começa a escrever um programa. Mas há, é claro, mais coisas sobreo os programas que escrevemos até aqui.
E particularmente, temos visto algumas coisas chamadas arquivos de cabeçalho. Este é outro termo técnico que se refere a um arquivo escrito na linguagem
chamada C, cujo nome termina não com .c, mas com .h.
Portanto, já vimos isso antes. Aqui, lembre-se, estava o mais simples programa escrito semana passada no Scratch.
Ele apenas diz hello, world quando você clicar sobre a bandeira verde. Este é o análogo, o mais análogo possível à direita,
desse programa hoje. Mas falta algo. E provavelmente está inquietando alguns de vocês,
porque o programa está um pouco mais curto do que era antes. Algo está faltando, que é esta linha aqui.
E eu acabei de escrever isso, de memória, mais cedo, mas se refere a um arquivo chamado stdio.h, que é for standard input output ponto h.
Então Io é um acrônimo no mundo dos computadores que geralmente se refere apenas a entrada e saída. Assim, o io.h padrão é apenas um arquivo muito popular
que é usado em programas C e que dá a capacidade de obter input e output do usuário.
E o faz fornecendo o printf, por exemplo, que naturalmente, permite que você gere alguma forma de output através desses efeitos colaterais
que descrevemos anteriormente. Mas quando eu escrevi meu outro programa, lembre-se, que, na verdade, tinha o get string, como BJ observou anteriormente,
onde eu posso obter uma linha de texto do usuário, Eu precisava de algo mais. E foi aí que acrescentamos, há um momento, um segundo arquivo de cabeçalho chamado CS50.h.
Portanto, estes arquivos de cabeçalho apenas dão acesso a mais funções do que você pode obter automaticamente da linguagem que você está usando,
que aqui é C. Tem a mesma essência, lembre-se na semana passada, quando comecei a bisbilhotar o menu de extensão do Scratch
e eu usei o bloco de tradução e o bloco de voz, o tipo de características mais extravagantes que estavam enterradas no menu de extensões.
Usar uma extensão no Scratch é similar a usar um cabeçalho num arquivo C.
Me dá acesso a um pouco mais de funcionalidade do que obteria de outra forma de graça e fora da caixa, por assim dizer.
Agora vamos continuar, e eu proponho que há tantas formas diferentes em que eu
poderia estragar tudo nos últimos minutos escrevendo esses programas. Eu poderia ter omitido um ponto-e-vírgula, como eu sugeri.
Talvez eu não tenha fechado minhas aspas. Eu poderia ter colocado meus parênteses errado. Eu poderia ter escrito palavras errado.
Há muitas maneiras diferentes que poderia ter estragado esse programa. E cá entre nós, eu estou meio torcendo que eu não tenha errado
em nosso primeiro programa juntos. Mas invariavelmente, em algum momento, talvez não em seu primeiro programa,
mas logo no início de aprender a programar ou aprender a programar em C, você vai estragar tudo.
E você vai cometer algum erro de digitação. Vai haver alguma desconexão entre o que seu entendimento é e o que você está tentando fazer com que o computador execute.
E isto é para dizer que há ferramentas, felizmente, que podem ajudá-lo a resolver esses problemas.
E a primeira é chamada de help50. Qualquer uma das ferramentas cujos nomes terminam com 50 são especificamente orientadas para a educação, escritas pelo Staff da CS50, treinamentos temporários
que utilizaremos para as primeiras várias semanas do curso mas depois, opcionalmente, removeremos isso,
já que você não precisará mais. E assim help50 é um comando para permitir que você resolva problemas, que de outra forma você não poderia
ver com clareza em seu próprio código. Vamos simular isto da seguinte forma.
Voltando para o primeiro programa que nós escrevemos em C, que era apenas isso, só dizia hello, world.
E há alguns lugares diferentes que poderia ter estragado tudo aqui. Por exemplo, suponha que eu estivesse me adiantando um pouco
e eu admiti o arquivo padrão io.h no topo do meu programa.
A implicação é que agora meu computador não vai saber o que é o printf, porque ele não foi incluído através do padrão io.h.
Portanto, vamos ver qual é a mensagem de erro. Esperemos que seja um mensagem autoexplicativa e que faça sentido.
Agora eu vou recompilar este programa, sabendo que já estava incorreto. E meu Deus.
Tipo, eu tenho mais linhas de erros que linhas de código. E esse é um tipo de realidade da programação.
Muitas linguagens de programação, um monte de ferramentas, francamente, não foram projetadas com a facilidade de uso em mente,
ou de forma amigável. Foram projetadas para serem sucintas e precisas. E tendem, infelizmente, a assumir que a o público
é tão técnico quanto a pessoa que escreveu o programa. Isto, é claro, pode ter um efeito contrário quando você está apenas aprendendo como programar, e você tem
de dar sentido à loucura críptica, como essa. Hoje não temos que nos concentrar em cada palavra
impressa na tela, mas vamos começar a reconhecer os padrões. Caminhando para um novo espaço e apenas reconhecendo
objetos familiares no mundo físico, vamos agora fazer isso com código. A coisa mais importante, talvez, quando você faz bobagem
e comete algum erro em seu código de tal forma que seu programa nem mesmo compila a partir do código fonte, para código de máquina,
é provável que você vá ver uma pista em direção ao topo do output de erro que diz o nome do arquivo onde você fez bobagem
e o número da linha onde você fez bobagem. Três implicando linha três, e depois cinco poderia
implicar ser a coluna ou o caractere nessa linha, mas depende do problema, se isso fizer sentido.
Então, na linha três, estou recebendo um erro, declarando implicitamente a função de biblioteca printf com tipo int const char star.
Quero dizer, quem sabe o que isso significa? Eventualmente você vai saber. Mas hoje, isso significa apenas que algo deu errado.
E talvez você não veja isso. Você poderia não saber, se eu não tivesse dito, que eu intencionalmente apaguei essa linha.
Então vamos ver se não podemos fazer sentido com isso, usando esta ferramenta. Help50 é uma ferramenta escrita pelo pessoal da CS50 que
ajudará a traduzir computador críptico arcano em mensagens mais amigáveis para humanos, com conselhos
como se você estivesse ensinando um colega, no curso ou no trabalho, digamos, no horário de trabalho.
Assim, para usar a help50, em vez de rodar o mesmo comando repetidamente vendo essa saída de erro, abra o help50 primeiro,
na janela de seu terminal, então escreva o mesmo comando com o qual você está lutando, por qualquer que seja o motivo, e dê Enter.
O mesmo comando vai rodar. Analisaremos, utilizando a help50 o que essa saída faz.
E vamos tentar destacar em amarelo o que reconhecemos. E depois vamos traduzi-lo para linguagem mais humana e amigável. Por exemplo, depois de executar a help50, pedimos ajuda, ponto ponto espaço.
Em amarelo, aqui está o que reconhecemos, o staff viu este problema antes. E então, aqui embaixo, você esqueceu de incluir o stdio.h, no qual o printf
está declarado no topo do seu arquivo? Então, espero que se nós reconheçamos o problema, e possamos orientá-lo com esse tipo de pergunta retórica
que faz você perceber, sim. Foi o que eu fiz de errado. Então agora eu posso voltar aqui, passar para o topo do meu arquivo,
e acrescentar include stdio.h. E agora repare, se eu rodar de novo make hello, voilá, o problema desapareceu por completo.
E poderíamos fazer isso o dia todo. Há tantos lugares para estragar tudo. Por exemplo, agora eu omiti o ponto-e-vírgula. Agora eu vou fazer make hello, agora sem o ponto e vírgula.
Agora vamos ter uma mensagem de erro diferente. E você vai ver, novamente, o nome do arquivo onde eu estraguei tudo, hello.c.
Desta vez está na linha cinco. E isso é verdade porque os números das linhas foram reduzidos depois que acrescentei mais coisas lá em cima.
E você pode ver o esperado ponto-e-vírgula após a expressão. Então este aqui é um pouco mais simples. Mas você poderia rodar o help50 neste comando,
só para obter conselhos um pouco mais explícitos. Então, help50 será seu amigo a qualquer momento que
tiver problemas para conseguir compilar seu código. Bem, deixe-me fazer algo bem ruim agora.
Eu escrevi código bonito mais. Eu identifiquei a palavra printf.
Incluí uma linha em branco aqui em cima. Só para deixar claro, eu coloquei essas chaves, por assim dizer, em suas próprias linhas.
Mas francamente, meu computador, ou O CS50 IDE não é tão específico. Eu poderia tecnicamente me livrar desta linha em branco.
Eu poderia mover essa chave aqui em cima. Eu poderia me livrar desta indentação e movê-la em sua própria linha.
E então eu poderia simplesmente mover essa chave aqui em cima. Assim, escrevemos um programa que tem agora apenas duas linhas, não seis.
Mas esperemos que agora, mesmo que que você nunca tenha programado antes, isso tudo corrija a forma errada de fazer as coisas.
Isto é como as pessoas no mundo real que não usam pontuação em seus posts nas redes sociais ou em seus e-mails ou mensagens de texto.
Simplesmente continuam e continuam e continuam e continuam... E sim, a informação está lá. Você pode entender o que estão tentando comunicar.
Mas, meu Deus, isso é irritante. É difícil de ler. Provavelmente há algum erro
e vai ser mais difícil encontrá-lo porque as coisas não estão bem equilibradas à esquerda e à direita, e na parte de cima e na parte de baixo.
Isto é o que seria descrito como estilo ruim. Meu programa ainda está correto. Eu tenho o stdio.h, eu tenho o ponto-e-vírgula, e tudo mais.
Mas é um estilo muito ruim. Porque é simplesmente feio. Não há muito espaço em branco. Não há muitas linhas em branco ou indentação
que só facilitam as coisas para você e para mim, para ler esta coisa de cima a baixo. Portanto, repare, ele faz a compilação.
Então, a help50 não vai me ajudar a consertar este problema porque ele se compila bem. Mas você pode executar outro programa que vamos chamar de style50.
Esta é outra ferramenta orientada para a educação que está instalada no CS50 IDE, permitindo a você descobrir
como melhorar o estilo de seu código. Então, quando eu executo o style50 sobre este código, agora mais bonito, parece bom.
Mas ainda está me dando conselhos. Está me dizendo para acrescentar algo chamado comentários. Alguns de vocês achou isto no mundo do Scratch.
Você pode acrescentar postites ao Scratch, que são tipo de notas para si mesmo que lembram o que algo faz, ou talvez explique ao seu colega
ou docente o que algo faz. C suporta isso também. Assim, por exemplo, se eu apenas quisesse ser pedante aqui e deixar
claro para a leitura humana meu código, o que estou tentando fazer, eu poderia dizer algo como "cumprimente o usuário".
E repare a sintaxe aqui. Eu coloquei uma nova linha acima da minha linha de código existente, e eu indentei de forma semelhante para que tudo se alinhe
visualmente bem. Eu já fiz barra barra, que diz, ei, compilador, este é um comentário.
Isto é apenas para os olhos humanos. Isto não é um código C real, por si só. Então eu pressiono a tecla espaço.
E então eu apenas digitei uma frase em inglês. E poderia ser qualquer idioma. Mas eu fui em frente e digitei cumprimentar o usuário.
Por quê? Bem, é apenas um lembrete para mim do objetivo da seguinte linha de código, que é para saudar o usuário.
Um pouco melhor que "hello, world".
E deixe-me apenas perguntar, mesmo que você nunca tenha programado antes, por que o primeiro comentário é melhor
do que o segundo? Por que eu deveria dizer, cumprimente o usuário em vez de print
"hello, world" na forma destes comentários. Sim, Olivia, o que você acha?
PLATEIA: Ok. Diz o propósito do código. DAVID MALAN: Sim, o propósito do código em oposição a quê? Que distinção você está fazendo?
PLATEIA: Versus dizendo a você exatamente o que está fazendo. DAVID MALAN: Sim, exatamente. Se seu comentário é quase idêntico ao código real,
você não está transmitindo muito mais informações para o leitor, quanto mais você mesmo no futuro. Explicando de forma mais geral, o objetivo desta linha de código
é cumprimentar o usuário, ou seja, um pouco mais descritivo. Agora, para ser justo, honestamente, este programa é tão curto que mesmo com o style50
sugira que você acrescente alguns comentários, se seu programa realmente tem uma linha de código apenas, você provavelmente não precisa de um comentário aqui.
No entanto, praticamente todos os outros programas que estamos vamos escrever aqui vão ser mais do que apenas uma linha de código, como esta printf.
Portanto, vai fazer muito mais sentido em breve o que virá, e aí sim vamos acrescentar
ao nosso código alguns comentários reais. Bem, deixe-me apresentar uma última ferramenta aqui que nos ajudará a resolver problemas conforme avançamos
para escrever programas mais sofisticados. E este é o check50. Esta é uma ferramenta específica que você irá usar em laboratórios ou em conjuntos de problemas,
nas tarefas do curso, para verificar a exatidão de seu código. Então, enquanto help50 apenas ajuda você a compilar seu código normalmente,
quando não está compilando nada, o style50 ajuda você a melhorar o estilo de seu código, check50
verificará a exatidão de seu código em alguns testes automatizados que nós, o staff, escrevemos que sejam consistentes com o que quer que seja
o problema do trabalho de casa. Por isso, escrevemos alguns testes para ter certeza que seu código está funcionando corretamente de acordo com nossas próprias especificações.
Então, como eu poderia rodar o check50? Isto dependerá totalmente do conjunto de problemas ou do laboratório.
E nós sempre, em conjunto de problemas ou laboratório, dizemos qual comando digitar para check50.
Não é algo que você poderia necessariamente descobrir por conta própria. Acontece que eu me lembro de que temos um check, que
é um teste, chamado CS50/problems/hello. Provavelmente você nunca executou este comando, idêntico.
Novamente, no conjunto de problemas ou no laboratório, nós sempre diremos o que digitar. Você não saberá o que digitar de outra forma, a menos que digamos qual teste usar.
Isto agora vai carregar meu arquivo hello.c para um serviço chamado GitHub, que mais uma vez é uma ferramenta popular para compartilhar código.
Nós a utilizamos para coletar submissões para isto. Em seguida, vou digitar minha senha. Você não vai ver. Em vez disso, você verá asteriscos ou bullets em uma página da web.
Vou pressionar Enter então. Vai verificar meu código. Vai fazer algumas reflexões. Está carregando agora, ponto ponto ponto.
E agora estamos apenas esperando para que a Internet responda. Porque em algum lugar nos servidores CS50, nós vamos
executar seu código após a compilação dele ou, neste caso, o meu, e certificando-se, sim, de que na verdade se comportou como deveria ter se comportado.
E o que você normalmente verá, esperançosamente, é um monte de sorrisos verdes dizendo que sim, que seu código existe, sim, que seu código compila,
e sim, por exemplo, imprime hello, world. Às vezes você pode ver caras carrancudas vermelhas, o que significa que não, seu código não funcionou exatamente como deveria, pelo laboratório,
ou conjunto de problemas. Nesse momento, volta-se para o código, de sua parte, para descobrir exatamente o que precisa ser consertado aqui.
Às vezes você verá a saída amarela com apenas um rosto amarelo reto, que só significa que não fomos capazes de executar um dado teste
porque algum outro teste já falhou. Portanto, é para ser um feedback relativamente rápido sobre a exatidão de seu código antes de submetê-lo e considerar pronto.
As instruções do check50 acompanham o próprio problema
no laboratório ou no conjunto de problemas. Portanto, alguns comandos finais aqui agora. Dentro desta janela terminal, eu posso fazer mais do que apenas rodar make e ./hello,
ou qualquer que seja o nome do meu programa. E eu posso fazer mais do que help50 e style50 e Check50, acontece que eu estou usando, na forma da IDE CS50,
meu próprio servidor na nuvem. Portanto, sim, estou usando um website. Mas a IDE CS50 é, na verdade, como se fosse seu próprio servidor
ou seu próprio computador na nuvem. Em algum lugar na internet, você tem seu próprio username e senha,
na forma da IDE do CS50. E somente você pode acessar os arquivos que você escreve, os programas que você
escreve e que são armazenados nesta IDE. E há mais algumas características para as quais vou chamar nossa atenção. Talvez a mais amigável seja este pequeno ícone de pasta no canto superior esquerdo.
Se eu clicar neste pequeno ícone de pasta, você vai agora ver o que é geralmente chamado de explorador de arquivos ou uma árvore de arquivos, que é apenas uma representação gráfica
dos arquivos em minha conta, ou na minha IDE, neste caso. Parece semelhante ao Mac OS.
Parecido com o Windows. E isto é apenas uma interface gráfica do usuário incorporada na IDE para que, por exemplo, se eu fechar clicando neste pequeno x
e eu quiser reabrir o arquivo, como você imaginaria em um Mac ou PC, é tão simples quanto um duplo clique no arquivo no lado esquerdo.
Mas note que eu não cliquei no hello. Porque repare o que acontece. Se eu abrir o hello, meu Deus, como, o que está acontecendo aqui?
Isto é um pouco confuso. Está vermelho. Há pontos. Alguém arrisca dizer por que estou vendo o que estou vendo?
Há chances de que você vai, acidentalmente, em algum momento, clicar em um arquivo como se fosse um hello em vez de em um arquivo como hello.c.
Sara, o que você acha? PLATEIA: É um código binário. Portanto, é a linguagem de máquina.
Portanto, não permite que o usuário veja, além do código que eles escrevem em C. DAVID MALAN: Sim, exatamente. O que você está tentando ver nesta aba é código binário, 0's e 1's.
Entretanto, esses 0's e 1's são tecnicamente mal interpretados no momento como caracteres ASCII,
ou caracteres Unicode. Então, lembre-se da semana passada, ASCII é o mapeamento entre números e letras.
E os números, é claro, são apenas padrões de 0's e 1's. E isto parece super críptico, porque estamos tentando interpretar, erroneamente,
os 0's e1's como se fossem caracteres ASCII. E lembre-se que há muito mais caracteres em ASCII e Unicode
do que de A a Z. E os números, há alguns caracteres não imprimíveis. E de fato, tudo isso que estamos vendo aqui
é apenas uma má interpretação de 0's e 1's que são instruções para o computador, código de máquina para o computador sendo
mal interpretado como texto. Portanto, se você não pode editar um arquivo binário como este, por assim dizer, você deve apenas fechar o hello quando você faz algo assim
e certifique-se de que você fez duplo clique e abriu seu arquivo de código fonte também.
Então, já vimos strings. E há outros tipos de dados. E há outras funções. E há loops e condições e muito mais.
Acho que estamos em um bom momento agora para talvez fazer uma pausa, deixar fluir. Que tal agora fazer um intervalo de sete minutos?
E quando retomarmos, vamos introduzir mais algumas características do C e vamos comparar com o que vimos na semana passada no Scratch.
Então, nos vemos em sete minutos. Muito bem, estamos de volta. Então, onde paramos? Estávamos vendo essa interface
no canto superior esquerdo. O explorador de arquivos, a árvore de arquivos, que apenas nos dá mais acesso gráfico para os arquivos em nossa conta.
Mas vamos agora fazer isto old school, linha de comando na janela do meu terminal.
Então, acontece que usando nossa janela terminal, podemos não só compilar código e executar código e executar check50, Style, help50,
e afins, nós podemos também manipular arquivos e pastas que existem em minha IDE.
Isso está no computador que eu tenho acesso aqui na nuvem. E o primeiro comando que proponho é que digitemos ls.
Ls é uma notação abreviada para lista. E muito simplesmente, ls lista os arquivos ou pastas em sua pasta atual.
Então isto seria como um duplo clique em sua pasta Meus Documentos no Windows, ou documentos no Mac OS. Ls apenas lista o conteúdo.
Agora, repare que o hello está um pouco estranho. Destacado em verde e há um asterisco atrás dele.
E isso é apenas uma pista visual de que esse arquivo é executável. Ou seja, que esse é um programa que você pode rodar com ./hello.
A estrela não faz parte do nome do arquivo. E, é claro, vemos hello.c. Agora, suponha que eu quisesse talvez renomear meu arquivo.
Bem, eu poderia, muito parecido com Mac OS ou Windows, ir até o explorador de arquivos aqui em cima. Eu poderia fazer Ctrl + Click ou clicar com o botão direito.
E veja que há um monte de opções de menu que aparecem como em seu próprio computador. E eu poderia renomear o arquivo aqui em cima.
Mas de modo geral, vamos fazer as coisas na linha de comando somente porque, rudimentar como algumas dessas operações hoje
são, vai ser uma interface muito mais poderosa de linha de comando para mim. Então, suponha que eu mude de ideia, e você sabe o que?
Não gosto dessa versão de hello. Eu quero apagar esse programa e começar de novo. Estritamente falando, eu não preciso apagar o hello eternamente.
Eu posso simplesmente recompilá-lo, e ele irá continuar sendo trocado e trocado. Mas se eu quiser removê-lo, eu posso digitar rm hello, e depois Enter.
E então eu serei perguntado, remover arquivo regular hello? Isso é apenas uma confirmação visual de que eu quero apagar.
E eu posso digitar y ou yes ou alguma resposta desse tipo. E se eu der y e Enter, nada parece acontecer,
mas observe o que aconteceu aqui em cima, no canto superior esquerdo. Note que o hello foi embora, deixando apenas hello.c.
E se eu digitar "ls" novamente, agora eu vejo apenas meu arquivo de código. Talvez agora eu queira mudar este programa, e eu não
queira escrever hello.c, mas goodbye.c. Bem, deixe-me fechar a aba lá em cima.
E sim, eu poderia dar clique direito ou Ctrl + Clique, mas, mais uma vez, não precisamos utilizar a interface gráfica.
Agora eu vou, ao invés disso, do mv hello.c goodbye.c.
Mv é o comando de mudança. E mesmo que fosse legal se chamasse renomear em vez de mover,
move apenas um arquivo para outro local ou para outro nome. Portanto, se executar hello.c goodbye.c.
Observe o que aconteceu no canto superior esquerdo. Agora meu mesmo arquivo é chamado de goodbye.c.
E se, novamente, eu digitar ls, eu posso ver que, de fato, ele foi renomeado.
Agora, eu vou voltar atrás porque eu quero ficar no meu programa "hello.c". Mas suponha que eu queira começar a organizar meus arquivos.
A seguir, vamos começar a escrever mais programas, e assim minha conta vai ficar um pouquinho confusa, com mais e mais arquivos ao longo desse dia.
Portanto, suponha que você queira criar uma pasta, também conhecida como um diretório. Vou digitar agora mkdir para criar um diretório.
E então o nome do diretório por exemplo, aula. Você pode chamá-lo do que quiser, mas se estou em uma aula, estou escrevendo código,
talvez eu queira armazenar tudo o que hoje arquivos em um diretório de aulas. Quando eu dou Enter, repare o que acontece com a árvore de arquivos aqui em cima.
Agora eu vejo uma pasta de aulas. Se eu clicar no triângulo, ele estará vazio porque eu não coloquei nada nele.
Portanto, agora eu vou mover hello.c para a pasta aula. Mv hello.c lecture, (lecture é aula, em inglês) e agora Enter.
E voilá, agora note que está dentro desta pasta de aulas. E de fato, se eu agora digitar ls, para lista, só vejo a pasta da aula.
Infelizmente, agora eu não tenho acesso a hello.c dentro deste ambiente de linha de comando
a menos que eu mude para esse diretório. Agora, no mundo dos Macs e PCs nós, obviamente, clicamos duas vezes em uma pasta e voilá estamos dentro dela.
Em uma interface de linha de comando você precisa elaborar melhor. Por isso vou fazer o cd, para mudar o diretório,
em seguida aula, e então Enter. E agora repare, poderia fazer mais sentido
porque todo este tempo temos visto em azul, este til aula barra. O til significa apenas o meu diretório pessoal.
Como minha própria conta, minha pasta padrão, meus documentos e janelas, ou documentos no Mac OS.
Isso é o que o til representa em notação curta. Aula é o nome da pasta que estou agora dentro.
Então é como se eu tivesse feito um duplo clique sobre aula no Mac OS ou Windows para abrir uma pasta.
Agora estou dentro desta aula na janela do meu terminal. Então, se eu agora digitar ls Enter, eu deveria ver
o arquivo hello.c que eu movi. Agora, deixe-me desfazer isto porque vou continuar
e manter as coisas um pouco mais simples, por enquanto. E suponha que eu queira mudar hello.c onde antes estava.
Última porção de sintaxe. Há esta notação curta para o que chamaremos de pasta dos pais.
Assim como nas árvores genealógicas, há a noção de pais e filhos, e netos, e assim por diante. Isso também é verdade em sistemas de informática, que possuem pastas.
E pastas dentro de pastas. E pastas dentro de pastas dentro de pastas. Há ali uma hierarquia muito parecida com uma árvore genealógica.
Então, se eu quiser mover hello.c um nível acima, Eu posso fazer mv hello.c espaço ponto espaço.
E isso é como dizer: "mova este arquivo para a pasta acima." Quando eu fizer isso, observe o que aconteceu no canto superior esquerdo.
Agora o hello.c não está dentro da pasta de aulas, mas abaixo dela. E, de fato, se eu digitar "ls" agora na pasta aula, não há nada lá.
Como eu subo a mim mesmo um nível acima nessa árvore genealógica que são estas pastas?
Agora eu vou digitar cd espaço ponto espaço. Então mudar o diretório para o principal.
Ponto ponto significa apenas o principal, o primeiro, o pai. A pasta acima, Enter. E agora, aparentemente, eu estou em til barra,
que é, mais uma vez, notação críptica resumida para seu próprio diretório pessoal... Sua pasta Meus Documentos ou pasta de documentos.
E se, por último, eu digitar "ls" aqui, terminei com esta pasta de aulas. Eu não quero me incomodar armazenando as coisas em uma pasta.
Eu não posso fazer rm para remover, como eu fiz para me livrar do hello, mas rmdir para remover um diretório.
E voilá, desapareceu. E eu desfiz todas os várias mudanças que eu fiz anteriormente.
Mas talvez agora faça mais sentido por que eu estava fazendo algo antes. Vamos abrir meu arquivo "hello.c".
Vou fazer o hello novamente, que é o caminho de volta onde paramos. E lembrem-se que todo este tempo eu tenho executado ponto barra hello.
Bem, por que isso acontece? Bem, assim como o ponto se refere ao ponto do seu diretório pai,
um único ponto se refere a seu diretório atual. Portanto, mesmo que isso pareça um pouco bobo,
ponto barra hello é apenas uma maneira muito explícita de dizer ao computador, execute o programa chamado hello
que está aqui mesmo em meu diretório atual. Ponto significa diretório atual. Ponto ponto significa diretório pai.
E aí vemos, finalmente, por que eu tenho digitado ponto barra hello todo este tempo. Mas novamente, é apenas o análogo de fazer algo
como clicar duas vezes em um Mac OS ou Windows.
Portanto, há outros comandos também, e com o tempo, você será exposto a eles e vai usá-los para vários problemas. Cp para copiar, por exemplo, é outro.
E muitos outros, mas são todos apenas comandos padrão. Eles não são específicos do CS50. Comandos padrão que nos permitem manipular arquivos e pastas
em um computador como este. Pergunta de Max. PLATEIA: Olá.
Sim, desculpe. Estava só pensando. Eu não entendo a diferença entre o programa hello e o programa "hello.c". Parece que aquele que não tem ponto c nele não é usado para nada.
DAVID MALAN: Oh, mas é. Então, lembre-se que nós temos duas coisas na história. Temos o código fonte, que é o código C que venho escrevendo.
E depois o código de máquina, que são os 0's e 1's que o computador entende. Tenho escrito todos os meus códigos no arquivo chamado hello.c.
Mas depois de compilá-lo com make, o programa make cria um novo arquivo chamado "hello". que tecnicamente contém apenas zeros
e uns. Isso é código de máquina, rodando quando faço ponto barra hello.
Então, novamente, posso usar rm me livrar do programa "hello". assim como eu fiz antes. E agora estamos de volta ao início da história
onde escrevemos este código a partir do zero. Se eu agora digitar make, e deixe-me fazer isso agora, ls. Note que eu só tenho um arquivo.
Vamos agora fazer make hello. Vejo essa saída críptica, mas se eu digitar ls novamente, agora eu tenho dois arquivos.
E isso porque só o verde com o asterisco é executável. Esse é o código de máquina que o compilador criou para mim.
E eu preciso dizer, eu contei uma mentirinha para vocês. Make por si só não é um compilador.
Veremos na próxima semana exatamente o que make faz. Mas, em resumo facilita com que possamos compilar nosso código,
mas mais sobre isso na próxima aula. Muito bem. Então, vimos apenas strings até aqui, mas acontece que em C,
e em muitas outras linguagens, há outras coisas conhecidas como tipos ou tipos de dados. Ou seja, você pode ter variáveis e valores
que não são apenas strings de texto, mas que talvez sejam inteiros, como números, um, dois, três, quatro.
Ou talvez valores de ponto flutuante, como 3.14159, ou outros valores semelhantes.
Você pode ter valores booleanos, que são apenas verdadeiro ou falso. Você pode ter caracteres ou chars, que são caracteres únicos.
Isto quer dizer, dentro de uma linguagem como C, há um monte de tipos de dados que estão disponíveis para você.
String é apenas um deles. E há ainda mais do que esses nesta lista aqui, mas esta é apenas uma lista de alguns dos mais comuns que veremos hoje
e usaremos essa semana no primeiro conjunto de problemas que permitem que você não diga ao computador apenas para armazenar um valor em uma variável,
mas que tipo de valor armazenar em uma variável. Além disso, temos na biblioteca do CS50 um monte de outras funções.
Já vimos o get_string. Mas também criamos funções que vocês podem usar para conjuntos de problemas, laboratórios, e além disso
permitem que você obtenha um único caractere através de um get_char. Isso pode permitir que você obtenha um número inteiro via get_int.
Isso pode permitir que você obtenha um valor de ponto flutuante, uma forma extravagante de descrever um número real, com um ponto decimal usando get_float.
Mas acontece que cada um destes tipos de dados, como int e float,
têm um número finito de bits. E lembre-se da semana passada, em que brincamos com as lâmpadas
e com bits e 0 e 1 mais em geral. Cada um desses tipos de dados
char, double, float, int, long, string, e assim por diante, tudo usa um número específico de bits.
E acontece que int, por exemplo, inteiros em C, usa apenas 32 bits.
E isso é ótimo, contanto que você queira contar até 4 bilhões, não mais que isso.
Veremos mais tarde hoje que, se você estiver usando apenas um número específico de bits você só pode contar até esse limite, e portanto, existem outros tipos de dados.
Por exemplo, long. Long é outro tipo de número em C que usa apenas 64 bits.
Dá mais poder, muito mais padrões de 0 e 1 para contar ainda mais alto. Da mesma forma, um double é como um valor de ponto flutuante.
Um número real com uma vírgula decimal e alguns dígitos depois dele. Um double permite que você tenha ainda mais dígitos depois dele do que um float.
Assim, veremos e usaremos alguns destes tipos de dados a seguir. Printf, da mesma forma, tem a capacidade de imprimir não apenas strings
como vimos, mas também diferentes formatos de códigos de outros tipos de dados também. Estes são um pouco mais crípticos tudo bem para buscar apenas conforme necessário,
mas você acabará precisando deles para casos comuns. Porcentagem c será o local a ser ocupado para impressão de um único caractere.
Porcentagem c para um char, por assim dizer. Porcentagem f vai ser para um valor de ponto flutuante.
Portanto, se você quiser imprimir um número real com um ponto decimal, você vai usar a porcentagem f. Se você quiser imprimir um inteiro usando print f,
você vai usar por cento i para inteiro. Se você quiser imprimir uma string já vimos por cento s. E se você quiser imprimir um número inteiro longo, também conhecido como
long, você vai usar por cento li. E há outros, mas estes são talvez os mais comuns.
E isso só significa que, mais uma vez, o C precisa que você, o programador, seja mais preciso. Você não pode simplesmente dizer, imprima isto.
Você tem que dizer à printf como imprimir a variável ou o valor que você está passando.
E, por último, parece que, em C, há um grupo inteiro de operadores, certamente matemáticos e vários outros
também. Assim como Scratch tem um kit completo de ferramentas de operadores. E basta dizer, por enquanto, que o C também suporta adição, subtração,
multiplicação, divisão, e até mesmo operador resto, que de forma um pouco críptica é representado com um sinal de porcentagem.
Não confundir com códigos de formato printf, mas isto quer dizer que alguns dos primeiros usos dos computadores, é claro,
foram todos orientados matematicamente em programas de planilhas eletrônicas. Programas como VisiCalc e similares antes de existir o Excel e o Google
Spreadsheets. E eles certamente, os computadores, são muito bons em matemática. E assim, estes são apenas alguns dos os operadores que agora verão
disponíveis para nós. Portanto, agora eu vou fazer isto. Deixem-me voltar à minha IDE depois de limpar as coisas
e começar de novo com nada na janela do meu terminal e sem abas abertas. Agora eu vou escrever meu próximo programa desta vez
usando mais algumas dessas funções. Agora vou criar um arquivo aqui em cima chamado addition.c.
Então addition.c, mas eu poderia chamar isso de qualquer coisa que eu queira, mas é importante acrescentar o ponto c.
Caso contrário, o computador não saber que é o código fonte em oposição ao código de máquina. Agora eu vou fazer uso da biblioteca do CS50.
Portanto, vou incluir o cs50.h. Vamos incluir o stdio.h, para que eu possa usar coisas como get_int e printf.
E depois, novamente, para essa aula, Vou apenas fazer int main void e, em seguida, as chaves.
E novamente, por hoje, aceite que isto é necessário. Mas vamos explicar dentro de uma ou duas semanas exatamente por que
continuamos a escrever no main void. Mas por enquanto, é como se a bandeira verde clicasse a peça.
Agora eu vou pegar um número inteiro do usuário. Suponha que meu objetivo agora não seja escrever um programa que recebe uma sequência de textos e imprime hello, Brian, ou hello, David.
Agora eu vou escrever um programa que talvez peça dois números inteiros, dois números, e, em seguida, apenas os junta.
Então, deixe-me fazer a mais simples das calculadoras usando código. Bem, vou continuar e declarar uma variável chamada
x, exatamente como um matemático faria. E eu vou atribuí-la ao valor da chamada get_int.
E eu direi apenas algo como x dois pontos. Eu poderia dizer o que eu quiser, o que é x?
Mas eu vou manter as coisas simples e dizer x dois pontos. Ponto-e-vírgula para terminar meu pensamento. Então, novamente, semelhante ao que eu fazia com string antes,
mas agora usando o get_int para obter um número ou um número inteiro do usuário. O parâmetro citado aqui ou argumento é a entrada
para obter get_int, que vai ser o prompt que o humano vê. O sinal de igual, lembre-se, é o operador de atribuição,
que diz, copie o valor de retorno à direita o inteiro que o humano vai digitar
para a esquerda. E a esquerda diz, me dê uma variável chamada x,
e me deixe armazenar inteiros nela. Portanto, antes, usamos string à esquerda e usamos get_string à direita.
A única diferença agora é int à esquerda, porque eu quero um número, e get_int na direita. Então agora eu vou fazer isto novamente e obter outro número.
Get_int, e eu vou dizer apenas, y dois pontos. Mas novamente, eu poderia dizer, o que é y ponto de interrogação, ou qualquer coisa em inglês.
Mas a última linha vai ser o mais interessante. Agora, vou continuar e imprimir, por exemplo,
a soma destes dois números. Mas o printf, mais uma vez, pega um input que diz o que imprimir exatamente.
Portanto, não posso digitar um número aqui ainda porque eu não sei o que o humano vai digitar. Por isso, vou colocar um placeholder.
Eu vou colocar porcentagem i, que diz, coloque um número aqui, que eu simplesmente ainda não sei o que é. E depois só para manter as coisas limpas, eu vou
fazer contrabarra n, que apenas diz, dê-me também uma nova linha. Isso é apenas um detalhe estético para mover o cursor para a próxima linha apenas
para manter as coisas limpas. Mas agora o printf vai pegar um segundo argumento. E quer você tenha ou não programado antes...
Brian, vamos a alguém na plateia, se possível. O que devo digitar após a vírgula se o objetivo deste programa
é muito simplesmente acrescentar dois números juntos? Mesmo que você nunca tenha programado antes, com base nos operadores que existem
e algumas das sintaxes que temos visto até agora, qual seria o seu chute? Mesmo que você nunca tenha feito isto antes.
Santiago, o que você acha? PLATEIA: Eu diria para escrever apenas x mais y.
DAVID MALAN: Sim, é simples e tão simples quanto isso. X mais y é a intuição certa. Vou acrescentar um ponto-e-vírgula ao final para concluir meu pensamento.
Mas de fato, computadores, e C neste caso, entendem absolutamente aritmética e operações matemáticas, então apenas digite
o que você quer dizer. Vou em frente agora e salvar o arquivo e descer. E eu não vou digitar "make hello" mais.
Agora quero digitar make addition, porque esse é o nome do meu arquivo implicitamente. Addition.c.
Quero compilar em um programa chamado addition. Assim espero, estou torcendo que não tenha cometido erros.
E vou continuar e rodar make addition. Tudo está bem, sem mensagens de erro.
Se eu tivesse cometido um erro nem sequer compilaria, help50 poderia ter sido a próxima tentativa. Agora vou continuar e rodar ponto barra addition.
E repare, primeiro me pede x. Agora vou fazer um. A seguir, me pede y.
Agora farei outro. E voilá, como propôs Santiago, eu vejo na tela x mais y,
ou o valor dois. E eu não codifiquei dois na mão. Eu substituí usando i, qualquer que fosse o resultado de x mais y.
Agora note, algumas características da função get_int para você. Suponha que você não esteja sendo muito cooperativo e você digite "gato" para x.
Note que get_int apenas ignora você e o pede de novo. Se eu digitar um cão, ele ignora e me avisa novamente.
Se eu digitar 1,23, ele ignora e me pede de novo porque quer um inteiro, neste caso.
Um número como um, dois, três, quatro. Ou negativo, um, dois, três, quatro, ou zero, ou qualquer coisa acima ou abaixo.
Muito bem, vou cooperar agora e dar-lhe o número um. O mesmo para y. Vai ignorar qualquer entrada não-inteira.
Portanto, se eu der um número como dois desta vez, espero obter a resposta de três. Muito bem. Então, temos uma calculadora básica em C. Estamos usando construção básica
de blocos como antes. Temos estes arquivos de cabeçalho, que apenas dá acesso a get_int e printf
respectivamente. Mas suponha agora que eu queira contar ainda mais alto. Sabe de uma coisa? Vamos tentar algo assim.
Vamos executar este programa mais uma vez. E agora eu quero mais. Que tal 4.000.000.000.000.
Então, aproximadamente... bem, exatamente... 4 bilhões. Esse é o número que eu quero digitar.
Note que x não gosta disso. Portanto, o get_int não aceita 4 bilhões.
Bem, deixe-me tentar talvez 3 bilhões. Não gostou.
Que tal 2 bilhões? OK, funcionou. Vou fazer uma pausa aqui.
O que está acontecendo, talvez? Agora novamente, nós, o Staff, escrevemos get_int, então nós
estamos rejeitando os gatos, e rejeitando cães, e rejeitando 4 bilhões, e até mesmo 3 bilhões.
Nesse caso, é um pouco menos claro. Por que rejeitamos 4 bilhões e 3 bilhões, o que vocês acham?
Com base no que já vimos. Por que é assim? Nathaniel, o que você acha?
PLATEIA: Há um limite sobre o tamanho do número uma vez que seria preciso muitos bits e bytes após o tamanho de 2 bilhões.
DAVID MALAN: Perfeito. Assim, inteiros, novamente, são implementados em C, como estes ints. Ints apenas usam 32 bits no total.
E você só saberia disso por ter sido ensinado ou se buscasse por aí. Mas na IDE CS50, e nos sistemas modernos, um inteiro é de apenas 32 bits.
E isso então convida a perguntar se você tem 32 bits ou 32 lâmpadas, até que altura você pode contar? Bem, acontece que com 32 lâmpadas, ou bits,
você pode contar aproximadamente até 4 bilhões. Você pode sem dúvida contar até 3 bilhões.
E, no entanto, get_int ainda está rejeitando. Mas isso é porque o get_int suporta inteiros de forma ampla
o que inclui não apenas números positivos, mas também números negativos e zero.
E a pegadinha é que, se você quiser suportar ambos os números positivos e números negativos, você pode representar 4 bilhões ou mais de valores totais possíveis.
Mas se você quiser ir tão longe à esquerda e até a direita com esse número linha que estou descrevendo,
você só pode contar tão alto quanto 2 bilhões na direção positiva e 2 bilhões negativos.
Porque isso ainda dá a você um total de 4 bilhões, mas não tão alto quanto 3 bilhões ou 4 bilhões.
Então, qual poderia ser a solução aqui? Bem, eu me lembro de observar anteriormente que existem outros tipos de dados.
Não apenas em ints e strings, mas também longs, o que literalmente são inteiros mais longos, ou seja, 64 bits.
Portanto, agora vou experimentar isso. Agora eu vou mudar get_int to get_long. Este get_int para get_long.
Vou mudar este int para long, e esse também. Portanto, o mesmo programa, a mesma calculadora, mas eu estou
agora usando um tipo de dado que usa mais bits para armazenar valores. Vamos rodar make additions novamente para recompilar meu programa.
E, droga. Eu estraguei tudo. Então vamos ver se não podemos descobrir o que está errado aqui.
Vamos rolar para cima. E isso está evidente. Às vezes - tive sorte aqui e só tem um erro, aparentemente,
nas mensagens de erro - isso não vai ser incomum que você tenha dois erros, 10 erros, em duas linhas de código.
Isto porque às vezes, quando você tem erros em seu código, o compilador às vezes fica apenas confuso.
E se ficar suficientemente confuso, começa a pensar que tudo é um erro em seu código. Portanto, o mais importante é que não importa
quantos erros você parece ter, sempre role até o topo da saída e trate primeiro o primeiro erro.
Então foi por isso que eu subi, olhando bem abaixo do que digitei, make addition, e aqui está o primeiro erro.
Addition.c na linha 10. Tudo bem. Não consigo ver a linha 10, então vamos rolar meu código para cima. E está dizendo algo sobre formato especifica o tipo int,
mas o argumento é do tipo long. Nunca tínhamos visto este erro antes, mas acho que posso inferir a partir disto.
Não é super críptico, embora não seja familiar. Acho que o que isto significa é que porcentagem, lembro que era para inteiros.
Eu acho que o que eu preciso é de um código de formato para números inteiros long,
que vai ser li. E peguei isso da minha cola de antes. Portanto, agora vou tentar novamente.
Make addition depois mudando o i para um li. Funcionou. Agora deixe-me fazer... opa, erro de digitação.
Agora, ponto barra addition. E agora vou digitar 4.000.000.000.000.
4 bilhões. Agora get_long está feliz, e aceitará um número inteiro tão longo
porque tem bits suficientes. Muito bem, perguntas sobre tipos como ints e longs,
ou funções como get_int ou get_long? Sim, Peter. PLATEIA: Sim.
Quando eu digitei 2 bilhões e ambos eram inteiros, bem,
só dá a você a resposta errada. Alguns números negativos. Isso é por causa dos bits e bytes? DAVID MALAN: De fato.
É a mesma resposta. Portanto, não demonstrei isso, mas se você calculou os dois 2 bilhões para x e 2 bilhões para y e depois você tenta juntá-los,
que daria matematicamente 4 bilhões. Mas novamente, uma int não é grande o suficiente para armazenar 4 bilhões
se quisermos também ser capazes de representam números negativos. Então Peter, o que você está vendo é que não cabe
o resultado no tipo de dados permitido. E veremos em um momento, ainda hoje, na verdade, quais as ramificações disso
mas o sintoma que você descreveu está correto. Você tentou enfiar um número muito grande dentro de 32 bits.
Mas você pode evitar esse problema, é claro, mudando para long. Vamos tentar uma outra coisa, e isso é um pouco curioso.
Agora eu vou escrever um programa ligeiramente diferente. E vou descrever isto como truncation.c.
Termo extravagante, mas vamos ver o que isto significa em apenas um momento. No topo disso, cs50.h. stdio.h.
E tudo bem, uma vez que você apenas começou com o primeiro problema de laboratório ou de conjunto, se demorar muito mais para digitar algumas dessas coisas.
Aqui estou trazendo da minha memória. Int main void. E agora estamos prontos para um novo arquivo de programa chamado truncation.c.
Vou continuar e pedir do usuário uma int, novamente. Assim como antes. Vou pedir ao usuário outra int, exatamente como antes.
E então eu vou fazer isso. Desta vez, quero fazer divisão. Portanto, não apenas um acréscimo, isso foi fácil demais.
Vou fazer uma divisão. Então, deixe-me me criar outra variável, z é igual a x dividido por y.
E deixe-me fazer uma pausa aqui por um momento para perguntar que tipo de dados devo talvez usar para z?
Esta linha de código ainda não está correta, porque lembre-se que a qualquer momento você cria uma nova variável à esquerda aqui, eu vou
precisar colocar algo para a esquerda do nome dessa variável para que C saiba que tipo de variável que eu quero.
E até agora temos visto string e int e long. Assim, você propõe que utilizemos um desses ou outra coisa para z?
Que tal o Jack? O que você acha? PLATEIA: Seria um float? DAVID MALAN: Sim, float.
Portanto, float, que é a abreviação de ponto flutuante, que é a forma que o programador tem de descrever um número real.
Agora eu vou fazer isso. Um float. Você deve ter adivinhado que o float,
se você digitar um número para x e outro para y o resultado é uma fração de algum tipo, então algo
com um ponto decimal. Precisamos armazená-lo em um float para que possamos realmente armazenar quaisquer que sejam os números após o ponto decimal.
Portanto, vamos em frente e façamos isto. Então vamos imprimir isto. Porcentagem f contrabarra n, porque desta vez, estou imprimindo um float.
E então agora eu vou imprimir o valor de z. E sabe de uma coisa? Sendo razoável, vou começar praticando o bom estilo aqui também.
Portanto, obtenha um número do usuário. Vou fazer outro comentário a mim mesmo. Obter outro número do usuário.
Mas, quer saber? Isto parece um pouco bobo. Eu posso combinar estas linhas. E por que eu não digo apenas: obtenha, por exemplo, os números do usuário.
Essa é uma forma razoável para comentar seu código. E depois vamos dividir x por y.
Mas mesmo isto está ficando um pouco pedante porque você pode meio que entender isso só de olhar. Portanto, talvez não precise de um comentário para isso.
Portanto, vamos simplificar assim. Agora vamos compilar isto. Make... vamos lá...
make truncation. Tudo bem, ele compila OK. E eu gosto de como usamos um float aqui.
Isso me parece correto. Então, vou rodar truncation. Agora eu vou digitar, por exemplo, 4 para x e 2 para y.
OK, eu gosto disso. São 2.000, então esse é o cálculo matemático correto. Que tal 1 dividido por 2.
Então x é 1, y é 2, e é 0,000000.
Tudo bem, bem, talvez isso foi apenas uma casualidade. Vamos tentar novamente. Que tal 2/3?
2 dividido por 3. Isso também não está certo.
Está bem. Que tal 4/3? Vamos colocar um número maior para o x, portanto 4/3.
OK, está mais perto da direita. Mas este é um exemplo, esta semana, de um bug.
Então, meu código compila. Sintaticamente está bem, mas este é um erro lógico.
Como se de alguma forma eu tivesse usado código C de forma inadequada. Então, o que pode estar acontecendo aqui?
Por que 1 é dividido por 2 e 2 dividido por 3, ambos aparentemente zero, seguido de seis zeros após o ponto decimal.
E mesmo 4/3 me dá 1.000000 em vez de 1.33333.
Nina, o que você acha? PLATEIA: Porque com int não reconhece os decimais.
Assim, 4/3 só vai em 4 de uma vez, portanto, retorna um 1.
E você precisa usar outros tipos de caracteres, como um float ou um double se você quiser o decimal real.
DAVID MALAN: Sim, exatamente. Este é mais sutil do que os outros erros que eu cometi. Mas C, como a maioria das linguagens de programação, vai levar ao pé da letra.
Portanto, se do lado direito desta expressão, na linha 11, Eu estou literalmente fazendo x dividido por y.
Primeiro você tem que se perguntar, bem, qual é o tipo de x? Qual é o tipo de y?
Se ambos são ints, por definição de como C funciona, você vai retornar um número inteiro como sua resposta.
Portanto, se dividir 1 por 2. Sim, matematicamente isso é 0,50000.
Entretanto, se você converter isso em um int, na medida em que x e y são ints,
a forma como C funciona é truncando tudo após o ponto decimal. Portanto, faz as contas corretamente, mas por não cabe em ponto flutuante
não cabe pontos decimais e os números em um número inteiro, você perde todos esses dígitos após o ponto decimal porque você pode
apenas colocar a parte inteira da resposta em um número inteiro. Não é relevante que eu esteja salvando o resultado em um float
porque é tarde demais. A conta matemática já foi feita do lado direito. E assim, estou armazenando um número inteiro em um float para que eu possa imprimi-lo como um float,
mas é tarde demais. Tudo após o ponto decimal já foi jogado fora. Então, quais são as implicações disto, ou como eu poderia consertar?
Bem, eu poderia mudar toda a parte direita. Bem, se o problema é que x e y são ints,
bem, deixe-me apenas mudá-los para floats. E mudo isto aqui, x para um float, y para um float,
e assim por diante. Isso resolveria o problema. Mas é uma solução pesada para este problema. Mudar todo o código.
Você pode, ao invés disso, ser um pouco mais inteligente, e pode convencer o computador a converter um número inteiro em um float
por algo conhecido como casting. Portanto, posso entrar aqui, e usando uma nova sintaxe, posso dizer float y.
E posso até mesmo, por uma boa medida, mas não é estritamente necessário, fazer o mesmo com x. Você pode em C, cast ou typecast de um tipo de dado para outro
literalmente entre parênteses, apenas colocando o novo tipo de dados que você deseja. E se isso fizer sentido matemático para um ser convertido no outro,
o computador o fará para você. Então, desta forma, estou dizendo ao computador, converta x em um float,
converta y em um float, depois faça as contas. E assim, antes, quando eu digitava um e dois para x e y, respectivamente,
agora é como se eu tivesse digitado 1,0 e 2,0.
E 1,0 dividido por 2,0 será matematicamente 0,5,
mas porque x e y agora foram convertidos antecipadamente em floats, a resposta vai continuar um float, 0,5.
E isso é o que vai ficar armazenado em z e finalmente impresso. Portanto, se eu rodar de novo truncation tendo agora resolvido este problema.
Ponto barra truncation. Digito um, digito dois. Não tenho que digitar o 0,0 eu mesmo.
O computador está fazendo isso por mim através dos casts entre parênteses. Agora vejo que a resposta é de fato 0,5.
Muito bem. Então parece que agora temos algum controle muito básico de baixo nível sobre o que você pode fazer com o programa.
Vamos agora acrescentar tudo de volta das características extravagantes que tínhamos no Scratch na semana passada, para que possamos começar a fazer programas mais interessantes.
Assim, variáveis e outro termo técnico chamado syntatic sugar também está entre as características do C aqui.
Então, lembre-se da semana passada, quando nós queríamos ter uma variável chamada contador igual a zero. Podemos ir em frente e defini-la desta forma.
Em C, a partir de hoje, vamos dizer o contador é igual a zero. Mas, além disso, precisamos especificar o tipo de dados dessa variável,
e precisamos acabar com nosso pensamento com ponto-e-vírgula. Assim, ao passo que nós definimos contador como zero na semana passada, agora
isso vai ser traduzido dessa forma simples do lado direito. Bem, o que vem depois disso? Bem, se quiséssemos incrementar a variável counter na semana passada por 1,
adicionando um, nós usamos esta peça de quebra-cabeça. Esta semana, precisamos ser um pouco mais explícitos e dizer algo assim.
Counter é igual a counter mais um, e ponto-e-vírgula para terminar o pensamento. Agora, isto pode parecer matematicamente paradoxal.
Tipo, como pode counter ser igual a counter mais um? Isso simplesmente não funciona logicamente.
Mas esse não é o sinal de igualdade, neste caso. Em C, como em outras linguagens que vamos encontrar,
o sinal de igual é o operador de atribuição da direita para a esquerda. É como dizer: pegue counter mais 1,
e armazene esse resultado matemático à esquerda. Portanto, qualquer que seja o counter, acrescente 1, armazene o resultado no counter depois disso.
Efetivamente, aumentando seu total por um. Essa operação é muito comum em programas que veremos ao longo do período, onde você só quer somar algo
porque você quer manter o controle da contagem de alguma coisa. Então, acontece que há algo de syntatic sugar, que
significa que há uma maneira diferente de fazer isso, sintaticamente, que não dá a você qualquer nova capacidade que você já não
tenha em C, mas é ligeiramente mais agradável ou mais rápido de digitar. Portanto, esta linha de código em C é idêntico a dizer esta linha de código
em C. Counter mais igual 1 ponto e vírgula significa pegar a variável da esquerda,
e acrescentar 1 a ela. E é um pouco mais sucinto, apenas tornando seu código um pouco mais legível porque são menos coisas para nós
humanos lermos. Mas você pode ir além. Syntatic sugar existe, portanto,
para que você não precise digitar isso. Em vez disso, você pode apenas fazer counter + +. O counter + + é a notação de mão mais curta
em C por apenas adicionar 1 a uma variável. Muito bem. Além das variáveis, o que mais tem em nosso kit de ferramentas da semana passada?
Bem, nós também tínhamos a noção, é claro, de condições. Uma condição era como uma bifurcação na estrada que
poderia permitir que você fizesse isso, esta outra coisa, ou algo mais tudo junto. No Scratch, por exemplo, se quiséssemos na semana passada comparar duas variáveis,
x e y diferente de. Será que x é menos que y? E se sim, digamos que x é menor do que y.
Como podemos traduzir isto para C? Bem, a sintaxe vai ser muito simples.
Algumas coisas novas. Mais alguns parênteses, mais algumas chaves. Mas parece a mesma coisa, visualmente, embora em forma de texto.
Quero dizer, se um espaço, então entre parênteses incluir minha expressão booleana, lembram da semana passada?
X menos do que y é minha expressão booleana. Então repare que uso uma chave aberta e uma chave fechada.
E depois estou apenas deixando uma linha em branco para uma ou mais linhas de código assim como na semana passada.
E na verdade, vamos colocar a linha de código equivalente aqui. Imprimir utilizando printf, x é menos do que y, contrabarra n.
Então, já fizemos essa tradução antes. Say é como printf, tal como se agora fosse "se".
Estritamente falando, especialmente se você já programou antes, você não precisa destas duas chaves se você só
tem uma linha de código dentro da condição. No entanto, estilisticamente, para CS50 e para o style50,
sempre inclua essas chaves, em suas próprias linhas.
Muito bem, que mais podemos fazer no Scratch? Lembre de que podemos fazer if else. E podemos ir em um ou outro sentido na bifurcação.
Em C, o código correspondente vai se parecer com isto. Portanto, é quase o mesmo de antes. Eu acabei de acrescentar mais uma chave aberta e uma chave fechada.
E deixe-me só acrescentar os printf's. E você pode ver que em C isto é como o preto e branco, a versão baseada em texto do que era gráfico na semana passada,
mas a idéia é a mesma. Você só tem que começar a reconhecer aonde vão os parênteses, as chaves, os ponto-e-vírgula,
e todo esse tipo de coisas visuais. Muito bem, vamos fazer mais uma comparação com o Scratch.
Aqui está um onde eu disse que if x is less than y, say x is less than y. Else if x is greater than y, say x is greater than y.
Else if x equals y, say x equal to y. Agora, aqui é onde Scratch e C divergem.
Porque Scratch é feito para ser muito fácil de usar e não exigir longas explicações sobre operadores de atribuição, MIT for Scratch
usa o sinal de igualdade apenas para igualdade. Considerando que C usa o sinal de igualdade para atribuição da esquerda para a direita,
isto significa igualdade como antes. Muito bem. Agora, perceba a diferença aqui.
É uma tradução de linha por linha, embora possamos colocar else if na mesma linha e else if mesma linha.
Exceto que aqui é uma espécie de redundância idiota, certo? Em certo sentido, os humanos décadas atrás perceberam que, em certo ponto,
o sinal de igualdade já fora usado para atribuição. Então o que usar para a igualdade? Bem, o MIT ignorou esse problema e apenas usou um sinal de igual para igualdade.
Os cientistas da computação, inventando o C e linguagens subsequentes ao comparar dois valores na esquerda e a direita para a igualdade
usou dois sinais iguais, porque assim quiseram. Um sinal de igualdade é a atribuição da direita para a esquerda.
Dois sinais de igualdade são comparações de igualdade. Estes dois valores são iguais? Mas você sabe o que?
Isso não foi bem projetado. Está correto. Logicamente, tanto o meu código no Scratch e meu código C estão corretos,
mas alguém saberia dizer sobre a razão pela qual o código não está necessariamente bem projetado?
Estou fazendo um pouco mais de trabalho do que eu preciso. Eu poderia ajustar o código um pouco.
Eu poderia digitar um pouco menos de caracteres e fazer a mesma tomada de decisão correta.
Alguém sabe em que sentido esse código não está perfeitamente projetado?
[INAUDÍVEL], até você. PLATEIA: Sim, então você usou else is duas vezes.
Você poderia ter usado else no fim e sem a condição. DAVID MALAN: Observação muito boa. Estou usando else if duas vezes, o que, logicamente, está bem.
Este código está correto. Está perguntando e respondendo corretamente, mas pense nisso. Se x for menor que y, é uma possibilidade, uma bifurcação na estrada.
Else if x maior que y é a segunda. Qual é a única outra possibilidade logicamente no mundo da matemática?
Ou é menos do que ou maior ou igual a. Não há razão para preciosismo e fazer essa terceira pergunta.
Vamos simplificar o código e ligeiramente projetá-lo melhor. Basta se livrar do else if, como você propôs.
Não ficou muito mais limpo, nem muito mais curto, mas evita fazer uma pergunta adicional.
Assim, em vez de, talvez, três perguntas agora há apenas duas. E francamente, se você está escrevendo muito código ou faz isto repetidamente
esse tipo de diferença pode somar e de fato nos dar um código melhor.
Assim, agora que tenho a capacidade de usar estas condições. Vamos tentar converter isto em um programa.
Agora eu vou abrir um programa que eu escrevi antecipadamente, chamado conditions.c. E eu tenho no topo do arquivo meus dois includes, como sempre.
E então aqui embaixo, tenho o que vimos no slide, mais duas chamadas, ou usos, de get_int.
E então eu só estou fazendo essa pergunta aqui embaixo, if x less than y. Caso contrário, if x greater than y.
Caso contrário, faça o seguinte. Então é apenas um copia e cola de grande parte da tradução do Scratch.
Agora eu vou criar condições, novamente, conditions.c é o nome do arquivo. Sem erros aparentes.
Portanto, agora vou rodar ponto barra conditions, Enter. E x será 1, y é 2.
E de fato, x é menor do que y. Se eu executar isto, desta vez, com 10 e 5.
X é maior do que y. E, por último, se eu for em frente e executar isto com 4 e 4. X é igual a y.
Então agora eu tenho um programa em C que acrescenta condições para mim, o que, na verdade, permite que eu tome decisões e imprima
uma coisa ou outra. Mas deixe-me fazer algo ligeiramente mais extravagante.
Agora eu vou abrir outra coisa. Vamos escrever este programa a partir do Scratch. Suponha que eu queira escrever um programa chamado agree.c
que estimula a idéia como estas estúpidas formas que você tem que concordar ao usar um software
pela primeira vez ou coisa parecida. Ou mesmo quando eu apaguei um arquivo antes e tive que digitar yes ou y
para prosseguir. Agora eu vou incluir cd50.h no topo. Agora eu vou incluir stdio.h no topo.
E depois meu int main void, que é copia e cola de antes. E agora deixe-me fazer isto. Não vou mais pegar um input do usuário, nem mesmo uma palavra.
Vamos manter as coisas simples e apenas perguntar ao usuário por y ou n, para sim ou não. Agora eu vou dar a mim mesmo um char, e eu o chamarei de c.
Mas eu poderia chamá-lo de qualquer coisa, como resposta. Mas c parece razoável se eu tiver apenas um char. Agora eu vou chamar a função, get_char.
E agora pergunto, você concorda, ponto de interrogação. E depois deixe-me ir adiante e comparar isto.
Portanto, se c é igual a y, imprima concordo barra n.
Caso contrário, se c for igual a n, imprima, por exemplo, discordo.
Agora, infelizmente, eu cometi dois erros aqui, onde pelo menos um
pode ser um pouco mais óbvio do que o outro. Alguém sabe quais erros ou bugs que eu poderia ter introduzido
neste programa? Alguém? Sim, que tal, Olivia?
O que você acha? PLATEIA: Para o Booleano você usou um sinal de igualdade simples, ao invés do duplo.
DAVID MALAN: Bom. Usei o sinal de igualdade simples em vez do duplo, portanto, preciso consertar isso. E há outro ainda mais sutil.
E isto porque o C é muito específico quando se trata de seus tipos de dados. Todo este tempo eu usei aspas duplas para strings,
mas acontece que em C você têm que usar aspas simples quando você está comparando caracteres individuais.
Então, vou entrar aqui e mudar apenas as aspas em torno de y e n para aspas simples.
Por que? Porque agora estou lidando com o mundo dos chars. Chars são caracteres individuais, como y ou n.
E quando você está falando sobre caracteres, você precisa de aspas literalmente assim. O nome da variável, c, não precisa de aspas.
Mas y e n precisam de aspas. Mas eu não preciso mudar nenhuma de minhas outras aspas no arquivo porque essas ainda são strings de texto que são frases ou sentenças.
Portanto, agora eu vou tentar rodar make agree. Compila OK. Agora vou rodar ponto barra agree.
Eu concordo? Agora vou digitar y. Concordo, gostei. Então, deixe-me tentar n, não.
Discordo. Eu deixei uma contrabarra n, então vou corrigir isso rapidamente
por uma questão de coerência. Vamos recompilar meu programa e fingir que isso nunca aconteceu. Mas deixe-me fazer isso agora de forma muito razoável.
Ponto barra agree. Eu quero concordar. E sim, y maiúsculo. Nada aconteceu.
E quanto ao n, N maiúsculo? Não aconteceu nada. Mas o programa ainda funciona. Se eu fizer com minúsculas, ele funciona.
E se eu fizer minúsculas, ele funciona. Então, o que está acontecendo? Bem, novamente, o computador vai levar ao pé da letra.
E mesmo que nós, humanos entendamos, ao final é uma maiúscula ou uma minúscula. Mas aqui você tem que ser mais explícito.
Portanto, podemos fazer duas perguntas. Poderíamos fazer else if c é igual a Y, assim maiúsculo e com aspas simples.
Você poderia imaginar, novamente, dizendo agreed desta forma. Mas assim como na semana passada, quando eu comecei a copiar e colar blocos do Scratch,
não foi um projeto muito bom. Da mesma forma, este bloco de código, das linhas de 11 a 14, é quase idêntico
a 7 até 10. Vamos apenas nos livrar algumas porções. E vamos ver se não podemos combinar estes pensamentos. Vamos expressar if c ==y, ou c==Y
E de fato, você pode usar esta barra vertical que é operador lógico,
e ele faz duas perguntas ao mesmo tempo. Acontece que você pode fazer isto com a noção de e, uma lógica
e, usando | |. Mais sobre isso em outro momento. Mas duas barras verticais são equivalente a apenas dizer,
se este, à esquerda ou isto à direita. E agora, se eu salvar e recompilar o programa com make agree
e ponto barra agree. Você vai ver que eu posso digitar y em minúsculo, ou Y em maiúsculo,
e agora funciona. Assim, mais uma vez, terá sido correto acrescentar apenas outro "elseif" e outro "elseif".
Mas novamente, não é necessário porque posso combinar estes pensamentos e tornar meu programa mais bem projetado.
E note também, durante todo este tempo eu tenho sido muito estrito quanto à indentação, cada vez que estou dentro de chaves.
Indentando cada vez que tenho uma condição se ou uma else if. Portanto estou manifestando, assim espero, o bom estilo estético também.
Tudo bem. Bem, agora vamos considerar que temos a capacidade de não apenas expressar condições, mas também estas coisas chamadas loops.
Bem, acontece que no Scratch nós temos loops muito simples. Faça o seguinte eternamente. C é um pouco mais desajeitado.
Não há uma palavra-chave eternamente em C, mas podemos imitar esta idéia da seguinte forma. A maneira mais próxima de traduzir eternamente em C
é, na verdade, dizer while, que até que faz sentido. enquanto for o caso, faça isso,
mas é preciso ser ainda mais explícito. Você não pode simplesmente dizer while e então dizer printf hello, world.
Acontece em C que while, semelhante a uma condição, está constantemente perguntando, decidindo se deve ou não continuar.
Muito semelhante, mais uma vez, a uma condição com sua própria expressão booleana. Assim, em C, precisa colocar parênteses após a palavra while,
e você tem de perguntar algo dentro desses parênteses. Você tem que dizer algo como, x greater than y, x less than y,
ou similar a isso. Mas isso é curioso, já que, se você quiser fazer algo eternamente, quem se importa com a pergunta?
Você só quer que a resposta seja eternamente sim. Ou em termos informáticos, sempre true.
E de forma direta, se sempre quiser true, escreva a palavra true.
Portanto, mesmo que isto pareça um pouco esquisito, em C é como você deliberadamente induzir o que nós vamos chamar de loop infinito, que nunca para, porque true é sempre por definição
true. Você não precisa nem mesmo fazer uma pergunta mais complicada. Você poderia colocar um sinal "menor que", "maior que", ou algo parecido.
Mas se você quiser que algo aconteça eternamente, esta é a forma mais canônica de expressar algo eternamente.
Bem, e se você quiser fazer algo finamente muitas vezes? Bem, nós podemos fazer isso em C, utilizando também o que é
chamado de um loop "for", ou um loop "while". Bem, vamos considerar ambos, um por vez.
Portanto, se eu quiser fazer algo 50 vezes, a forma manual mais mecânica que posso pensar é contar com meus dedos, certo?
Um, dois, três, até 50, de alguma forma. Ou 10, no máximo, em minhas mãos.
Então, como posso fazer algo finitamente e muitas vezes em C? Bem, eu tenho à minha disposição variáveis.
Então, vou criar uma variável chamada counter. Inicializá-la em zero ponto-e-vírgula. E o tipo de dado será int, porque eu apenas
preciso contar, como contamos com os dedos. Mas sabe de uma coisa? Counter é meio verboso. Programadores sempre que eles estão contando frequentemente, apenas contando de zero
costumam usar i como inteiro, ou c como caractere, ou s para string.
Você não quer fazer isso sempre em seu código. Às vezes é melhor que suas variáveis sejam nomeadas de forma mais descritiva,
mas para uma variável idiota que vai apenas contar de zero para cima, vamos manter as coisas simples e chamá-la de i. Agora eu posso fazer um loop while novamente, mas agora eu
tenho que fazer uma pergunta porque não quero que isto funcione eternamente. Eu quero que funcione 50 vezes. Que pergunta eu poderia fazer?
Bem, por que eu não verifico? Enquanto i < 50. Então é como contar com 50 dedos.
Vamos começar com zero e seguir contando, mas não através de i igual a 50. Desde que i seja menor do que 50, faça o seguinte.
O que eu quero fazer? Quero continuar imprimindo hello, world. Hello, world. Hello, world. Mas eu ainda não terminei.
Porque em cada iteração disto, em cada ciclo deste laço, Preciso fazer mais uma coisa, matematicamente.
Preciso acrescentar outro dedo. Ou, em outras palavras, eu preciso acrescentar 1 a i.
Então, agora eu vou colocar i igual ao que quer que seja agora, mais um. Mas novamente, temos alguns syntatic sugar apenas
para que fique um pouco mais limpo, mais ajustado. Eu poderia fazer i += 1. Ou ainda mais sucintamente, i + +.
Portanto, mesmo que isto seja muito mais irritante de implementar do que no Scratch onde o MIT apenas retorna o que você quer, em C, temos todos os blocos de construção
agora com variáveis e com loops para implementar a noção de repetição
um número finito de vezes. Mas há outra maneira de fazer isso. E como você deve ter descoberto com o conjunto problema zero,
há diferentes maneiras de conseguir os mesmos objetivos no Scratch. Da mesma forma, em C, eu poderia fazer isso.
Eu poderia apenas começar a contar de 1 até 50. Portanto, não maior que ou igual, em seu teclado,
ou menor que ou igual a. Assim em C, como em outras linguagens, você usa apenas dois caracteres.
Você faz menor que, seguido pelo sinal de igual. E isso expressa menor ou igual a.
Isto também está correto. Se eu começar a contar de 1, preciso contar até 50. Você pode fazer isso.
Não faça isso. Isto é pouco convencional. E como os programadores vão, geralmente, como fizemos semana passada, quando começamos sempre contando de zero com todas
as lâmpadas desligadas, também os programadores vão começar em zero e contar até 50. O que dá zero até 49, implicitamente.
Portanto, faça isto, não do outro jeito. Mas isso significa que você pode resolver problemas de várias maneiras.
Há outra maneira, também. Poderíamos começar a contar de 50 até zero.
A única diferença é que temos que fazer i - - (menos menos) em vez de i ++. Então, novamente, são três diferentes maneiras de resolver o mesmo problema.
E novamente, você começará a ser capaz de puxar de cabeça e você também começará a ver padrões comuns em código da aula, seu TF
ou código de assistência ao ensino, livros e referências on-line. Há formas melhores de fazer as coisas,
embora todas estejam certas. Tudo bem. Mais uma abordagem de loops aqui. Acontece que há outro loop que é um pouco mais críptico,
e é chamado de loop "for". E ele permite que você automatize - ou melhor, que você expresse todos esses passos de forma mais concisa.
Então: for printf hello, world nos aproxima um passo mais de imprimir
hello, world 50 vezes. Mas a declaração for, como a declaração while,
vem com o necessário parênteses depois, mas desta vez você pode colocar mais coisas entre parênteses.
Não se trata apenas de uma expressão booleana. Primeiro, a primeira coisa entre parênteses é que você pode inicializar qualquer variável que quiser que tenha algum valor.
Eu poderia dizer encontre igual a zero, ou mais sucintamente, int i é igual a zero ponto-e-vírgula.
Mas o caminho para o loop parece um pouco bagunçado. Você pode fazer várias coisas em uma só linha. A segunda coisa dentro dos parênteses de um loop for
é uma condição que você deseja verificar repetidas vezes. E a última coisa no parênteses de um loop for
é uma atualização, ou uma incrementação ou decrementação pela qual você pode fazer i = i +1 .
Ou melhor, vamos apenas fazer i += 1. Ou ainda mais sucintamente, i + +.
Esta talvez seja a forma mais convencional em C e em outra linguagem para fazer algo 50 vezes,
ou um número finito de vezes. É um aspecto diferente das coisas que vimos até agora. Há ponto-e-vírgula em lugares mais estranhos.
Há mais coisas entre parênteses. Então, novamente, você vai desenvolver a familiaridade com isso com o tempo. Mas por enquanto é só perceber que isto diz, inicialize i como zero.
Verifique a condição. Se for menor que 50, imprima hello, world. Então atualize i.
Em seguida, verifique a condição. Se for menos de 50, imprima hello, world. Então incremente i.
Em seguida, verifique a condição. Depois, se for menos que isso, imprima hello, world. Assim, a inicialização da variável acontece uma vez.
Todo o resto acontece repetidas vezes e repetidas vezes até que você tenha feito isso 50 vezes.
Muito bem. Então, com esses blocos, é mais ou menos isso que será a nossa tradução de Scratch em C. Vamos agora começar
a construir programas um pouco mais interessantes na prática por exemplo, a abstração.
Assim, a abstração, lembre-se, era este princípio de solução de problemas onde você pode simplificar de outra forma detalhes mais complicados.
E a abstração é uma simplificação além de detalhes mais complicados ou detalhes de implementação, como poderia dizer um programador.
Assim, por exemplo, vou escrever um programa aqui chamado meow, semelhante para a semana passada, mas desta vez em C.
E a fim de fazer um meow de gato textualmente, vou criar stdio.h no topo.
No main void aqui embaixo. Novamente, estou em um arquivo chamado meow.c.
E eu incluí stdio.h e o main void int. E agora vou continuar e fazer algo assim.
Printf, entre aspas, "meow", contrabarra n. E eu quero que este gato mie textualmente três vezes.
Vamos salvar esse arquivo. Make meow. Muito bem. Agora, ponto barra meow. Miau, meow, meow, meow em todo texto.
Portanto, não tão bonitinho como o gato na semana passada, mas está correto. Mas não está muito bem projetado, certo?
Porque eu estou me repetindo. Eu copiei e colei literalmente, e esse é um mal hábito. Mas agora temos a capacidade de fazer coisas com loops.
Então, vou apagar esta parte da função. E deixe-me tentar lembrar do exemplo anterior.
Se eu quiser fazer algo três vezes eu poderia usar um loop while, mas isso vai pedir um monte de linhas de código. Vou fazer isto.
Int i = 0 . i menor que três. i + +.
Críptico, mas isto, mais uma vez, é a maneira de fazer algo de fato
um número finito de vezes. Inicializar algumas variáveis, como i para zero, verificar uma condição,
e continuar incrementando a variável uma e outra vez para que execute um total de vezes.
Agora, eu vou imprimir o meow por dentro.
Agora eu vou recompilar meow usando: make meow. Vamos ponto barra meow, e voilá.
Agora o programa está indiscutivelmente melhor projetado. Mas vamos avançar agora. Lembrar que a trajetória da outra semana não era apenas implementar meow
com o melhor design, sem repetir a si mesmo, usando assim um loop. Mas lembre-se que nós introduzimos a abstração que
era uma peça de quebra-cabeça personalizada chamada meow. Assim, em C, acontece que temos a habilidade para fazer nossas próprias funções também.
E a sintaxe vai custar um pouco para que se acostume, mas avancemos fazendo isso. Vou me livrar da minha printf aqui.
E no fundo do meu arquivo, na verdade, no topo do meu arquivo vou continuar e digitar void meow void.
O que é muito críptico hoje, mas novamente, este é bom que seja bem direto, copiar e colar por agora.
Agora eu vou fazer printf meow. Apesar de ainda não termos explicado, nem o faremos hoje,
o que significa esta palavra-chave void, o que eu fiz das linhas três a seis foi criar minha própria função personalizada.
C não vem com uma função chamada meow. A biblioteca do CS50 não vem com uma função chamada meow.
Mas agora graças a mim, existe uma função chamado meow cujo único objetivo na vida é apenas imprimir meow.
Mas o que há de legal nisto agora é que aqui embaixo, como com o Scratch na semana passada, eu posso agora chamar uma função chamada meow.
E meu código é um pouco mais legível porque diz o que faz apenas através do nome da função.
E deixe-me ir em frente agora e compilar isto. Make meow. Até agora, tudo bem.
Ponto barra meow, e parece funcionar bem. Mas eu não amo o fato de que eu implementei meow
na parte superior do arquivo. Não é um grande problema. Por convenção, normalmente colocaremos funções personalizadas na parte inferior do arquivo.
Por quê? Somente para quando um programador, ou no nosso caso, um professor quiser entender seu código de cima a baixo.
É apenas uma convenção humana para colocar o programa principal, a função main, na parte superior de seu arquivo.
O problema é que quando eu faço isso, eu vou ter criado um problema para mim mesmo. Quando eu rodo make meow meow, droga.
Dois erros gerados, e assim há dois bugs a serem resolvidos. Mas primeiro, Brian, uma pergunta do grupo.
BRIAN YU: Havia uma pergunta que veio do chat sobre o porquê na linha cinco, por exemplo, você não tem
um ponto-e-vírgula no final do loop for. E na linha 11 você não tem ponto-e-vírgula no final do nome da função.
Então, por que algumas linhas precisam de ";" no final, e outras não? DAVID MALAN: Uma pergunta muito boa. Por que algumas dessas linhas não têm ponto-e-vírgula, mas outras têm?
A melhor resposta, sem querer ser chato, é honestamente "porque sim". A forma como a linguagem foi projetada era que você deveria, em geral
terminar seus pensamentos ao expressar verbos ou ações ou funções com ponto-e-vírgula.
E vimos isso depois de printf, por exemplo. Acabamos de ver isso depois de meow. No entanto, quando você está usando outras construções de programação,
como loops ou como funções personalizadas, você não tem ponto-e-vírgula lá.
Por quê? Alguns humanos anos atrás decidiram que nós não precisamos de ponto-e-vírgula nesses lugares. E esta é uma dessas coisas que demorará um pouco para internalizar,
reconhecendo aonde essas coisas vão e aonde não vão. Mas até agora os únicos lugares em que vimos ponto-e-vírgula
estão no final das funções, como meow e printf aqui. E agora, estranhamente, por dentro dos parênteses para esse loop for.
Mas novamente, quando se trata de conjuntos de problemas e do laboratório e assim por diante, será bom você se referir a exemplos como estes nos slides
e as referências da seção para que você possa envolver sua mente em torno destes padrões. Então, agora eu vou resolver os dois problemas que eu pareço ter criado aqui.
Não parece óbvio, mas é parte do que já vimos antes. Declaração implícita de função meow é inválida em C99.
C99 se refere à versão de 1999 de C - a linguagem que estamos usando, mas está apenas ficando confuso.
Bem, por que isso acontece? Bem, deixe-me rolar até aqui e notar que o C, e, por sua vez, o meu compilador, eles não são tão brilhantes assim.
Tipo, eles só vão fazer o que eu disser para fazer explicitamente. E o problema no momento é que quando o compilador ler meu código
de cima a baixo, à esquerda ou direita, não antes da linha 11
a função meow existirá. No entanto, estou tentando na linha sete usar essa função de meow.
Portanto, meu compilador simplesmente não sabe o que meow é porque não encontrou meow ainda. E o compilador não é suficientemente inteligente, ou não
fácil de usar o suficiente para ler tudo primeiro e depois decidir se houver algum problema. Só vai lê-lo de cima a baixo,
e vai gritar com você no momento em que encontra o problema. Portanto, a solução para isto é muito simplesmente, mover a função
para o topo de seu arquivo. Mas, mais uma vez, isso é irritante porque então você têm que ir pescar sua função main que pode
estar dezenas de linhas abaixo no arquivo. Ou há outra maneira, e nós explicaremos isto no devido tempo.
Mas você também pode copiar a primeira linha de sua função personalizada.
Coloque-a no topo do seu arquivo, acima de main. E depois, à pergunta de Brian termina isso com um ponto-e-vírgula.
Isto é estranho. Isto é o que é geralmente conhecido como um protótipo, apenas uma dica.
É uma espécie de forma inteligente de dizer ao compilador que existirá uma função chamada meow, mas ainda não há.
Mas saiba que vai haver. E é apenas uma espécie de alternativa, bem comum, para resolver esse problema em particular.
Muito bem. Então, agora eu vou fazer mais mudanças. Suponha que eu queira realmente terminar com este exemplo de meow
assim como fizemos no Scratch. Por meio do qual também permitimos que meow tome um certo número de meow como entrada.
Portanto, não quero ter este loop for em minha função main. Suponhamos que eu só queira poder dizer, meow 3, dentro da minha função main.
Três sendo, portanto, o input para a função meow. Agora eu preciso mudar minha função personalizada, assim como eu fiz na semana passada.
Acontece que... e mais sobre isto nas semanas que virão... isto menciona um void aqui na linha 11, refere-se ao valor de retorno ou saída
desta função. Resumindo, minha função personalizada meow hoje não tem valor de retorno.
Não produz nada por si só, em vez disso apenas tem um efeito colateral de impressão, visualmente na tela.
Mas tem uma entrada. E se você quiser que uma função em C aceite inputs ou argumentos,
você pode literalmente fazer algo como, o nome do tipo que você quer e o nome do variável que você deseja.
Então, suponha que eu queira que meow pegue como input algum número, vamos chamar de n. E eu quero usar esse número em um loop.
Eu poderia então fazer algo assim. Para int i obter zero, i < n, i + +.
Eu posso então cercar meu printf com chaves. Agora veja, como na semana passada, com minha implementação final de meow,
minha função customizada pode receber input como indicam os parênteses. i não tem saída por si só, é por isso que estou deixando void aqui.
Mas mais uma vez, vamos explicar o void mais detalhadamente ao longo do caminho. Mas agora estou usando essa entrada dentro do loop for.
Portanto, mesmo que isto seja uma nova implementação em C, estou usando os mesmos blocos de construção. Estou usando um loop for, como antes, mas em vez de codificar 3,
ou 50 como eu fiz antes, agora apenas plugo essa variável, assim como o Scratch me permitiu fazer também.
Bem, e se eu quiser fazer algo ainda mais extravagante. Sabe de uma coisa? Vou fazer isso. Suponha que nós queiramos obter informações do usuário,
mas nós queremos que ele forneça um tipo específico de input. Agora eu vou apresentar um outro tipo de laço.
E este vou pegar de meus arquivos, o código que eu trouxe comigo hoje. E vou continuar e copiar sobre um arquivo chamado positive.c,
que vai insistir que o usuário me dê um valor positivo. Isto também está no site do curso.
Agora sigamos pelo código que eu escrevi. Aqui no topo do meu arquivo, eu estou incluindo alguns cabeçalhos, agora familiares.
Aqui no topo do meu arquivo, eu estou incluindo alguns cabeçalhos, agora familiares. E aqui embaixo, eu estou incluindo um protótipo. Isso é uma dica para uma função que vai ser chamada,
muito simplesmente de get_positive_int. Portanto, esta é uma função que apenas vai obter um número inteiro positivo.
Então, em minha função main, repare que vou usar isto. Vou obter uma variável chamada i na linha 10,
e eu vou obter um int positivo por parte do usuário. E depois vou imprimir. Mas o que é interessante agora é que eu tenho esta abstração adicional.
A biblioteca do CS50 não vem com uma função chamada get_positive_int, mas vem com uma função chamada get_int.
E repare o que eu fiz aqui entre as linhas 15 e 24. Aqui embaixo, declarei uma função chamada get_positive_int,
e repare que esse é o meu próprio nome da função personalizada. Não é necessário nenhum input, apenas obtém um número inteiro positivo do humano.
Mas agora perceba que têm um valor de retorno. Anteriormente eu usava a palavra void para dizer a ausência de entrada
ou a ausência de saída. Aqui ainda uso para dizer: sem inputs. Apenas recebe sempre positive.int.
Mas eu estou dizendo int do lado esquerdo do nome desta função personalizada porque esta função tem saída.
Qual vai ser a saída? Repare aqui na linha 17, eu crio uma variável e a chamo de n.
Então tenho uma última característica nova de C hoje, este loop que é chamado, não um loop while, mas um loop do while.
Um loop do while é quase o mesmo que um loop while, exceto que faz cegamente uma coisa primeiro antes de verificar uma condição.
Então note aqui que eu vou fazer o seguinte. Chamo get_int com esse prompt, inteiro positivo,
e depois armazeno o valor de retorno na variável chamada n. Então aqui embaixo, observe que eu estou dizendo que enquanto n menos de um.
Sintaxe meio estranha, mas se matematicamente eu quiser que o usuário dê um número inteiro positivo,
isso é tecnicamente a mesma coisa que querer que o usuário me dê um número inteiro e apenas assegure-se de que não é menos do que um.
Porque se for menos de um, é zero ou um -1 ou -2, isso obviamente não é um número inteiro positivo. Então, como posso expressar isto em código?
A única coisa nova no momento agora é o fato de que existe essa coisa chamada do while. E mais uma vez, o valor de do while é que você fará as coisas pelo menos
uma vez e depois verificar uma condição. Um loop while verifica a condição primeiro e depois faz algo.
Isto é o que eu quero neste caso, no entanto. Eu quero fazer isto. Obter um número inteiro do usuário, incitando-o a um número inteiro positivo.
Então enquanto n é inferior a 1 - então se o humano digitar zero, ou -1, ou -2, o que eu quero fazer?
A mesma coisa novamente e de novo e de novo. Portanto, a leitura é bastante gramatical. Faça o seguinte enquanto n for menor que um.
E, por fim, e a única outra nova linha aqui é retorno de n. Esta é a maneira que um programa pode devolver algum valor.
Ele pode devolver um valor, não imprimindo na tela, não dizendo isso de forma audível ou visualmente a partir da boca de um gato.
Ele devolve no sentido que o que está sendo devolvido aqui é n, que é um número inteiro que corresponde à saída desta função.
Por que isso é útil? Bem, vamos rolar de volta para cima. Vamos agora tomar como certo que a função get_positive_int existe.
E agora repare como nós podemos utilizá-la em main. Eu chamo get_positive_int à direita.
Retorna um valor que eu digo que é do tipo inteiro. Estou armazenando esse valor de retorno na esquerda desta variável chamada i.
E então eu estou imprimindo i. E assim como na semana passada com o meow, exemplo no Scratch, agora que eu implementei get_positive_int,
está meio fora da vista, fora da mente. Eu sei que pode ser feito, e eu posso abstrair
os detalhes de implementação subjacentes chamando-a apenas pelo nome.
Mas há uma coisa estranha que eu quero ressaltar sobre esses detalhes de implementação. Por que eu declarei n aqui fora?
Toda vez que eu criei uma variável, eu fiz isso. Acontece que temos tido sorte durante todo este tempo,
e sempre que eu declarar variáveis, elas tecnicamente precisam estar entre chaves. As chaves pertencentes à função main ou minhas outras funções
que escrevi até aqui. Mas neste caso, o problema é quando você declara uma variável dentro de chaves,
você se depara com o que nós chamamos uma questão de escopo. O escopo de uma variável é as linhas de código em que ela existe.
O escopo de uma variável são as linhas de código onde você pode usar essa variável. E a ideia de hoje é que se você
declarar uma variável dentro de chaves como aqui na linha 26 e 28, que você deve fazer através de um do while, essa variável, n,
só existe dentro daquelas chaves. O que significa que não se pode comparar contra um da linha 29.
O que significa que você não pode devolvê-lo na linha 30. Ela simplesmente não existe mais. Então você está fazendo todo esse trabalho, obtendo a variável n, e depois boom.
Desaparece quando você sai dessas chaves. Portanto, a solução para isso, por mais idiota que pareça,
é que você pode declarar n inicialmente em sua própria linha 25. Você não precisa atribuir um valor, até porque
você vai atribuir um valor eventualmente. Mas novamente, para criar uma variável, como eu continuo dizendo, basta declarar uma variável.
Você não precisa defini-la como tendo um valor necessariamente imediato.
Portanto, esta é uma forma de contornar o que é também conhecido como uma questão de escopo.
Tudo bem, com todos estes quebra-cabeças agora no lugar, por assim dizer, agora eu vou propor que resolvamos
algo um pouco mais gráfico. Então você vai se lembrar, é claro, do Super Mário, um dos primeiros problemas
de conjuntos que vimos na semana passada. E dentro deste jogo há um monte de coisas visuais. Por exemplo, há este visual desde o início, onde
há quatro pontos de interrogação no céu. E estes pontos de interrogação, se você pula para cima e por baixo deles, te dão moedas, por exemplo.
Então, deixe-me chamar nossa atenção para isso, e perguntar, bem, como eu poderia escrever um programa em C que apenas imprime quatro pontos de interrogação?
Bem, agora eu vou fazer isto. Agora eu vou escrever um programa chamado mario.c. Agora eu vou incluir stdio.h. em um arquivo chamado mario.c.
Me dê uma função main, int main void. Abordagem simples. Printf one, two, three, four, contrabarra n ponto e vírgula.
Isto não é tão legal ou bonito como o jogo old school, mas se eu rodo make mario e então ponto barra mario, voilá.
Eu tenho uma aproximação muito ruim destes quatro blocos no céu
usando apenas Ascii, ou chamada de arte Ascii. Mas eu posso fazer um pouco melhor do que isso. Lembrem-se que agora temos a capacidade de usar loops.
Por isso, eu poderia dizer que, int i é zero. i é menor que quatro, i + +.
E então eu poderia imprimir um ponto de interrogação de cada vez. E, em seguida, no fim do meu programa, eu
poderia imprimir uma nova linha só para mover o cursor no último momento. Eu não quero fazer isso a cada ponto de interrogação,
porque então seria vertical. Quero fazer isso somente no final. Portanto, agora se make mario, e agora run mario .
O mesmo resultado exato, mas um pouco melhor no sentido que agora está usando um loop em vez de um valor codificado rígido.
Mas deixe-me ser um pouco mais esperto agora, e deixe-me fazer isto. Deixem-me emprestar a lógica desse exemplo inteiro positivo
e fazer algo assim. Vou criar uma variável chamado, n, para um número. E deixe-me fazer exatamente como antes.
Vamos obter um número inteiro do usuário, e perguntar ao usuário pela largura dos tijolos que eu quero imprimir.
Portanto, nem sempre será quatro. Talvez seja um número variável. E então agora eu vou fazer isto enquanto n < 1.
Igual a minha lógica anterior. E quer saber? Uma vez que eu tenha um valor de n -
deixe-me ir em frente aqui em cima e criar um comentário. Obter um número inteiro positivo do usuário.
Isso explica o que essas linhas fazem. Eu não preciso comentar cada uma das linhas. Você não pode comentar tudo, mesmo que fizer sentido para você.
Agora vou imprimir os pontos de interrogação. Para que eu possa fazer um loop.
Para int i recebe zero, i < n dessa vez, i + +.
E agora eu posso imprimir um único ponto de interrogação sem uma nova linha. E, em seguida, no fim do meu programa, eu
pode imprimir um único nova linha ponto e vírgula. Agora eu vou aumentar o tamanho da minha janela terminal.
Make mario. E agora... caramba. Declaração implícita de função get_int.
Aqui é onde help50 pode ser minha amiga. Então agora eu vou run help50 make mario.
Vou pedir ajuda. Você parece ter um erro em mario.c na linha nove. Por declaração implícita da função get_int,
Significa que é o nome do compilador, que veremos na próxima semana... significa que não reconhece o get_int.
Você se esqueceu de incluir cs50.h em que get_int foi declarado no topo de seu arquivo. E de fato, eu o fiz.
Então, deixe-me consertar isso. Então include cs50.h.
Salvar o arquivo. Recompilar com make mario. E vamos adiante agora, e fazer ponto barra mario,
e vou criar uma largura de quatro. É a mesma coisa. Vou criar uma largura de 40. Agora eu tenho esse dinamismo.
Vou criar uma largura de 50, e assim por diante. Portanto, agora temos um programa que é muito mais dinâmico, mas sabe de uma coisa?
Vamos aprimorar isto um pouco mais. Mais tarde, em Super Mario Brothers, tem esse submundo
aqui onde você vê estas grades de tijolos, e deixe-me chamar nossa atenção para isto. Isto parece ser vários tijolos tanto horizontal como verticalmente.
Portanto, há uma largura e uma altura. Então, como posso imprimir, talvez seja três por três.
Três tijolos por três tijolos. Vou entrar no meu programa aqui.
Me livrar das interrogações de antes. E considere como eu poderia imprimir de três em três.
Bem, a má abordagem aqui, se eu voltar ao meu código, seria imprimir três destes.
E depois talvez mais três. Talvez mais três, e depois mais três.
Mas, é claro, esse copiar e colar não dará certo a longo prazo, mas tudo bem. Make mario.
Ponto barra mario. Muito bem. Eu tenho uma espécie de grade que se parece com esta coisa aqui.
Não é exatamente igual, mas pelo menos é a idéia certa. Mas essa não é necessariamente a melhor maneira de fazer isso.
Eu quero três em cima e três embaixo. Bem, acontece que usando C podemos expressar isso também.
Vou fazer isso. Agora eu vou imprimir por exemplo, o seguinte.
Agora eu vou imprimir não apenas hash, hash, hash, novamente e de novo e de novo. Vou fazer isso.
Vamos imprimir uma linha de cada vez. Assim, for int i =0, i < 3 , + +
Eu não sei o que eu estou prestes a fazer ainda, mas eu sei que vou fazer isso três vezes. O que eu quero fazer três vezes?
Bem, eu quero três linhas, e em cada linha eu quero três hashes. Então, você sabe o que pode fazer? Você pode aninhar loops.
Vou fazer for int j = zero, j < 3, j + +
Eu não sei o que eu estou fazendo ainda, mas eu faço sei que vou fazer isso três vezes. E talvez você possa ver aonde isto vai dar.
Três coisas três vezes, isto vai me dar todos os nove tijolos. Desde que dentro disso, por assim dizer, esse loop aninhado,
eu imprimo um desses hashes. Desde que depois desse loop, eu imprima uma nova linha por aqui.
Portanto, para ser claro, mesmo que não seja óbvio, à primeira vista, o que está acontecendo, já sabemos que esse é o tipo de sintaxe que você usa para fazer
algo finitamente e muitas vezes, três. Esta é a mesma sintaxe, mas eu sou usando um nome de variável diferente.
Assim eu posso acompanhar dois valores diferentes. Essencialmente, linhas e colunas.
E depois estou apenas imprimindo um único tijolo cada vez. Mas depois que eu tiver terminado de imprimir uma linha inteira, quero mover o cursor para uma nova linha.
Então, deixe-me tentar isto. Agora eu vou fazer make mario no meu código. Ponto barra mario, e voilá.
Agora eu estou usando um loop aninhado para imprimir tijolos assim. E eu posso mudar isso. Se eu quiser fazer 10 por 10, tudo o que eu tenho que fazer é mudar isso em um só lugar.
Ou se eu quisesse ser extravagante, eu poderia usar get_int novamente. Eu poderia obter a largura e altura a partir do usuário
e fazer de forma dinâmica. Mas agora, se eu fizer 10 por 10, por exemplo, eu posso ver pelo menos uma grade ainda maior.
Então, se você se pergunta como os Irmãos Super Mario, ou francamente qualquer jogo hoje em dia em um PC ou celular são feitos,
e eu digo: com este tipo de geração de mapas. Talvez antigamente foram codificados, talvez gerados,
usando código que você pode imaginar para gerar tijolo por tijolo dessa forma, para que, em última análise, seu jogo até mesmo, seu mundo,
fosse parcialmente gerado dinamicamente. E nós já temos os blocos construtores através dos quais se pode fazer isso.
Infelizmente, nós não falamos ainda das limitações
do que os computadores podem fazer. E em nossos últimos minutos estávamos preparando o cenário para coisas com as quais os computadores não são bons.
E na verdade, problemas que são latentes em praticamente tudo que fazemos hoje, mas procuro evitar cuidadosamente tropeçar.
Esta foto aqui é uma foto da memória de um computador típico, ou RAM, memória de acesso aleatório. É apenas uma das peças de hardware que você
tem em seu telefone, seu desktop, seu laptop hoje em dia. E é onde os programas são armazenados quando estão em funcionamento.
Então, em um Mac ou PC, se você der clique duplo em um programa vai ser armazenado em uma peça de hardware que se parece com isto.
Quando você faz ponto barra mario e dá Enter, um programa como este, você está usando a RAM do CS50 IDE, mas é a mesma idéia,
em algum outro lugar na nuvem. Mas acontece que, se você têm uma quantidade finita de memória,
assim, você só pode fazer x coisas com ela. Você não pode resolver todos os problemas do mundo
se você só tiver uma quantidade finita de memória. E o que eu quero dizer com isso? Bem, agora eu vou criar outro programa aqui chamado imprecision.c,
e veremos por que eu nomeei assim, logo a seguir. Agora eu vou incluir o stdio.h, novamente, e int main void apenas
para criar uma instalação aqui. E depois deixe-me ir em frente e muito razoavelmente pedir ao usuário por uma variável chamada x com um tipo float.
Vamos pedir o valor exatamente como antes. Vamos pedir outro na forma de y, entre aspas.
Agora vou continuar, mas sabe do que mais? agora eu vou imprimir com %f o valor de x dividido por y.
Portanto, tenho certeza de que fizemos isso antes. Fizemos a divisão com valores. Desta vez estou usando floats, mas vamos em frente e vamos fazer isto.
Make imprecision... e eu fiz alguma coisa aqui. Implícito... eu continuo fazendo... implícito... declaração de função get_float.
Não fiz o que eu ensinei. Eu também preciso incluir a cs50.h, que é onde se define get_float.
Agora, deixe-me recompilar. Agora funciona. Agora vou run imprecision. E deixe-me ir em frente e digitar em um décimo.
OK. Então, um décimo é, de acordo com à minha muito simples calculadora aqui, 0,100000.
Mas estou ficando um pouco curioso agora. Acontece que o printf é até mais poderoso do que já vimos, e você pode imprimir mais do que apenas um dígito.
Suponha que eu queira imprimir não seis dígitos, mas talvez 10.
A sintaxe é um pouco estranha, mas, em vez de dizer %f, você pode, ao invés disso, dizer literalmente, ponto percentual e o número de dígitos
que você quer ver e depois o f. Então, agora eu vou recompilar isto, make imprecision.
Agora, deixe-me fazer ponto barra imprecision e um décimo...
Bem, isso é um pouco curioso. Eu não me lembro de haver um 15 ao final de um décimo.
Bem, vamos ficar um pouco mais curiosos. Vamos imprimir 50 pontos decimais para nos aprofundarmos no que está acontecendo aqui.
Vamos recompilar meu código. E deixem-me rodar de novo o ponto barra imprecision e fazer um dividido por dez,
e oh meu Deus. Estou bastante seguro que na escola primária, quando todos nós aprendemos a dividir por dez, o professor disse ser um décimo, ou 0,1.
E eles nunca mencionaram o fato de que é 0,10000000149011, e assim por diante.
Então, o que está acontecendo? Bem, acontece que, poderosos como os computadores são, e com a sintaxe sofisticada que vimos hoje,
e um computador não consegue sequer calcular um décimo corretamente. E assim estamos nos deparando com uma limitação fundamental aqui,
que é que se computadores são finitos em sua capacidade, eles têm apenas tanta RAM, hardware, bits,
que se você usar apenas um número finito de bits, 32, por exemplo, ou 64,
sim, você pode contar facilmente, bem alto, ou com bastante precisão. Você não pode contar infinitamente, nem alto e nem com precisão.
Em algum momento você tem que começar a aproximar os valores. E de fato, é isso que que o computador está fazendo.
Se ele tiver apenas um número finito de bits, 32, através do qual representa um float. Há um número infinito de floats apontando para números reais.
Infelizmente, se você tiver um número finito de bits, você tem que começar a aparar algumas arestas. E é isso que o computador está fazendo.
Ele está representando um décimo o mais próximo que pode, e é isso o que significa dígitos significantes suficientes.
Agora, para a maioria dos problemas isso não deve ser uma preocupação. Mas pode muito bem ser uma grande coisa se você estiver fazendo contas,
lidando com finanças ou valores monetários ou operações militares onde há muitos números pequenos, cientificamente, e pode fazer a diferença.
E de fato, tem havido muitos exemplos no mundo real onde coisas ruins acontecem por causa desta chamada imprecisão.
E há outra questão que os computadores se deparam. Não apenas este ponto flutuante de imprecisão, mas mesmo inteiros
têm suas limitações. Lembre que os inteiros, é claro, podem ser representado em decimal ou em binário.
E se tivermos três lâmpadas ou três bits, vamos considerar como nós podemos contar em binário. Zero, zero, zero é onde começamos na semana passada.
001, 010, 011, 100, 101, 110, 111.
E agora, lembre-se da semana passada, que o número que conhecemos é sete em decimal. Como contar um dígito a mais?
Bem, eu carrego apenas um, por assim dizer. Mas se eu tiver apenas três lâmpadas ou por sua vez, três bits, ou seja, 32 bits.
Esse bit adicional, o transporte, desaparece. E assim há esse problema com os inteiros também.
E alguém notou antes quando você tentou fazer 2 bilhões mais 2 bilhões,
não poderia caber no resultado. Isso porque os inteiros também são assim, se tiverem apenas 32 bits ou um long em C. Se for apenas 64 bits, esses são grandes
números, mas eles não são infinitamente grandes. E nós, humanos, tropeçamos nisso de vez em quando.
Você deve se lembrar de ouvir sobre isso, o bug do milênio. Muita coisa deu problema no mundo,
todos estavam preocupados com catástrofes em 01/01/2000, porque os seres humanos tinham decidido, sem enxergar o longo prazo,
armazenar anos usando apenas dois dígitos. Assim, 1995 seria representado como 95, 96, 97, 97, 98, 99.
Em seguida, em torno da mudança do ano de 1999 a 2000, qualquer programa ou sistema de computador que ainda estava usando dois dígitos
acrescentaria, é claro, 1, ao bater da meia-noite. Infelizmente, se não houver um terceiro dígito disponível, ele desaparece.
E o mundo inteiro confunde o ano 2000 para o ano 1900,
porque 1900 foi assumido como sendo o prefixo. E acredite, os humanos estão prestes a fazer isso novamente
no ano de 2038, que está logo ali. Vamos ficar sem bits para acompanhar o tempo.
Porque anos atrás, os humanos decidiram, razoavelmente à época, usar 32 bits para representar números.
Usar 32 bits para contar o número de segundos a partir do ano, uma data, 1 de janeiro de 1970.
Foi aí que o tempo teve início, no âmbito da computação, e temos contado os segundos desde então.
Infelizmente, com 32 bits, você só pode contar até 4 bilhões. Infelizmente, com 32 bits, você só pode contar até 4 bilhões. E infelizmente, vamos atingir o quarto bilionésimo segundo em 19 de janeiro
no ano de 2038. Portanto, a menos que todos nós atualizemos nossos Macs e PCS, e pior ainda, sistemas e satélites incorporados e qualquer hardware dos dispositivos
que agora usamos, estamos prestes a nos depararmos com esse problema novamente onde, de repente, será como em 1º de janeiro de 1970
novamente. A menos que nos coloquemos à frente deste problema. Assim, com todo o poder que temos visto em C e todas as capacidades
que vimos em C e no Scratch, ainda há estas limitações fundamentais. Portanto, quando se trata de resolver seus problemas em C e, por sua vez, em CS50,
vai ser sempre importante estar atento a estas restrições e, em última análise, encontrar soluções até mesmo para estes problemas.
Mas por enquanto, vamos respirar um pouco, e deixá-lo com seu primeiro conjunto de problemas em C com Mario e muito mais.
Nos vemos da próxima vez. [MÚSICA TOCANDO]
